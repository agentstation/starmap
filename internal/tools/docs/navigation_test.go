package docs

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestBuildBreadcrumbs(t *testing.T) {
	g := &Generator{}

	tests := []struct {
		name     string
		items    []Breadcrumb
		expected string
	}{
		{
			name:     "empty breadcrumbs",
			items:    []Breadcrumb{},
			expected: "",
		},
		{
			name: "single breadcrumb (current page)",
			items: []Breadcrumb{
				{Label: "Current", Path: ""},
			},
			expected: "**Current**",
		},
		{
			name: "multiple breadcrumbs",
			items: []Breadcrumb{
				{Label: "Catalog", Path: "../../"},
				{Label: "Providers", Path: "../"},
				{Label: "OpenAI", Path: ""},
			},
			expected: "[Catalog](../../) / [Providers](../) / **OpenAI**",
		},
		{
			name: "breadcrumbs with special characters",
			items: []Breadcrumb{
				{Label: "Test & Demo", Path: "../test/"},
				{Label: "Page <1>", Path: ""},
			},
			expected: "[Test & Demo](../test/) / **Page <1>**",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.buildBreadcrumbs(tt.items...)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestWriteBreadcrumbs(t *testing.T) {
	g := &Generator{}

	t.Run("write breadcrumbs to file", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("", "breadcrumbs_test_*.md")
		require.NoError(t, err)
		defer os.Remove(tmpFile.Name())
		defer tmpFile.Close()

		items := []Breadcrumb{
			{Label: "Home", Path: "../../"},
			{Label: "Docs", Path: "../"},
			{Label: "Page", Path: ""},
		}

		g.writeBreadcrumbs(tmpFile, items...)

		content, err := os.ReadFile(tmpFile.Name())
		require.NoError(t, err)

		expected := "[Home](../../) / [Docs](../) / **Page**\n\n"
		assert.Equal(t, expected, string(content))
	})

	t.Run("write empty breadcrumbs", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("", "breadcrumbs_empty_test_*.md")
		require.NoError(t, err)
		defer os.Remove(tmpFile.Name())
		defer tmpFile.Close()

		g.writeBreadcrumbs(tmpFile)

		content, err := os.ReadFile(tmpFile.Name())
		require.NoError(t, err)
		assert.Empty(t, string(content))
	})
}

func TestBuildFooter(t *testing.T) {
	g := &Generator{}

	tests := []struct {
		name      string
		backLinks []Breadcrumb
		expected  string
	}{
		{
			name:      "no back links",
			backLinks: []Breadcrumb{},
			expected:  "_Generated by [Starmap](https://github.com/agentstation/starmap)_",
		},
		{
			name: "single back link",
			backLinks: []Breadcrumb{
				{Label: "Back to Catalog", Path: "../"},
			},
			expected: "_[← Back to Catalog](../) | Generated by [Starmap](https://github.com/agentstation/starmap)_",
		},
		{
			name: "multiple back links",
			backLinks: []Breadcrumb{
				{Label: "Back to Providers", Path: "../"},
				{Label: "Back to Catalog", Path: "../../"},
			},
			expected: "_[← Back to Providers](../) | [← Back to Catalog](../../) | Generated by [Starmap](https://github.com/agentstation/starmap)_",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.buildFooter(tt.backLinks...)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestWriteFooter(t *testing.T) {
	g := &Generator{}

	tmpFile, err := os.CreateTemp("", "footer_test_*.md")
	require.NoError(t, err)
	defer os.Remove(tmpFile.Name())
	defer tmpFile.Close()

	backLinks := []Breadcrumb{
		{Label: "Back to Index", Path: "../"},
	}

	g.writeFooter(tmpFile, backLinks...)

	content, err := os.ReadFile(tmpFile.Name())
	require.NoError(t, err)

	expected := "---\n_[← Back to Index](../) | Generated by [Starmap](https://github.com/agentstation/starmap)_\n"
	assert.Equal(t, expected, string(content))
}

func TestWriteTimestampedFooter(t *testing.T) {
	g := &Generator{}

	tmpFile, err := os.CreateTemp("", "timestamped_footer_test_*.md")
	require.NoError(t, err)
	defer os.Remove(tmpFile.Name())
	defer tmpFile.Close()

	backLinks := []Breadcrumb{
		{Label: "Back to Home", Path: "../"},
	}

	g.writeTimestampedFooter(tmpFile, backLinks...)

	content, err := os.ReadFile(tmpFile.Name())
	require.NoError(t, err)

	// Check that it contains the expected parts
	contentStr := string(content)
	assert.Contains(t, contentStr, "---\n")
	assert.Contains(t, contentStr, "_Last Updated:")
	assert.Contains(t, contentStr, "UTC | ")
	assert.Contains(t, contentStr, "[← Back to Home](../)")
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestBuildNavigationSection(t *testing.T) {
	g := &Generator{}

	tests := []struct {
		name     string
		title    string
		links    []NavigationLink
		expected string
	}{
		{
			name:     "empty links",
			title:    "Navigation",
			links:    []NavigationLink{},
			expected: "",
		},
		{
			name:  "links without descriptions",
			title: "Quick Links",
			links: []NavigationLink{
				{Label: "Home", Path: "../"},
				{Label: "Docs", Path: "../docs/"},
			},
			expected: "### Quick Links\n\n- [Home](../)\n- [Docs](../docs/)\n",
		},
		{
			name:  "links with descriptions",
			title: "Resources",
			links: []NavigationLink{
				{Label: "API Docs", Path: "/api/", Description: "API documentation"},
				{Label: "Guide", Path: "/guide/", Description: "User guide"},
			},
			expected: "### Resources\n\n- [API Docs](/api/) - API documentation\n- [Guide](/guide/) - User guide\n",
		},
		{
			name:  "mixed links",
			title: "See Also",
			links: []NavigationLink{
				{Label: "Home", Path: "../"},
				{Label: "API", Path: "/api/", Description: "API reference"},
			},
			expected: "### See Also\n\n- [Home](../)\n- [API](/api/) - API reference\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.buildNavigationSection(tt.title, tt.links)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestWriteNavigationSection(t *testing.T) {
	g := &Generator{}

	t.Run("write navigation section", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("", "nav_section_test_*.md")
		require.NoError(t, err)
		defer os.Remove(tmpFile.Name())
		defer tmpFile.Close()

		links := []NavigationLink{
			{Label: "Providers", Path: "../providers/"},
			{Label: "Authors", Path: "../authors/", Description: "Browse by author"},
		}

		g.writeNavigationSection(tmpFile, "Browse", links)

		content, err := os.ReadFile(tmpFile.Name())
		require.NoError(t, err)

		expected := "### Browse\n\n- [Providers](../providers/)\n- [Authors](../authors/) - Browse by author\n\n"
		assert.Equal(t, expected, string(content))
	})

	t.Run("write empty navigation section", func(t *testing.T) {
		tmpFile, err := os.CreateTemp("", "nav_empty_test_*.md")
		require.NoError(t, err)
		defer os.Remove(tmpFile.Name())
		defer tmpFile.Close()

		g.writeNavigationSection(tmpFile, "Empty", []NavigationLink{})

		content, err := os.ReadFile(tmpFile.Name())
		require.NoError(t, err)
		assert.Empty(t, string(content))
	})
}

func TestGetCatalogPath(t *testing.T) {
	tests := []struct {
		depth    int
		expected string
	}{
		{0, "."},
		{1, ".."},
		{2, "../.."},
		{3, "../../.."},
		{4, "../../../.."},
		{-1, "."},
	}

	for _, tt := range tests {
		t.Run(strings.ReplaceAll(tt.expected, "/", "_"), func(t *testing.T) {
			result := getCatalogPath(tt.depth)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetProvidersPath(t *testing.T) {
	tests := []struct {
		depth    int
		expected string
	}{
		{0, "providers"},
		{1, "../providers"},
		{2, "../../providers"},
		{3, "../../../providers"},
	}

	for _, tt := range tests {
		t.Run(strings.ReplaceAll(tt.expected, "/", "_"), func(t *testing.T) {
			result := getProvidersPath(tt.depth)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetAuthorsPath(t *testing.T) {
	tests := []struct {
		depth    int
		expected string
	}{
		{0, "authors"},
		{1, "../authors"},
		{2, "../../authors"},
		{3, "../../../authors"},
	}

	for _, tt := range tests {
		t.Run(strings.ReplaceAll(tt.expected, "/", "_"), func(t *testing.T) {
			result := getAuthorsPath(tt.depth)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetModelsPath(t *testing.T) {
	tests := []struct {
		depth    int
		expected string
	}{
		{0, "models"},
		{1, "../models"},
		{2, "../../models"},
		{3, "../../../models"},
	}

	for _, tt := range tests {
		t.Run(strings.ReplaceAll(tt.expected, "/", "_"), func(t *testing.T) {
			result := getModelsPath(tt.depth)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetRelativePath(t *testing.T) {
	tests := []struct {
		name     string
		from     string
		to       string
		expected string
	}{
		{
			name:     "same directory",
			from:     "/docs/providers",
			to:       "/docs/providers",
			expected: ".",
		},
		{
			name:     "parent directory",
			from:     "/docs/providers/openai",
			to:       "/docs/providers",
			expected: "..",
		},
		{
			name:     "sibling directory",
			from:     "/docs/providers",
			to:       "/docs/authors",
			expected: "../authors",
		},
		{
			name:     "nested path",
			from:     "/docs",
			to:       "/docs/providers/openai/models",
			expected: "providers/openai/models",
		},
		{
			name:     "invalid path falls back",
			from:     "relative/path",
			to:       "/absolute/path",
			expected: "/absolute/path", // Falls back to 'to' path on error
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getRelativePath(tt.from, tt.to)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestProviderBreadcrumb(t *testing.T) {
	g := &Generator{}

	result := g.providerBreadcrumb("OpenAI")

	expected := []Breadcrumb{
		{Label: "Catalog", Path: "../../"},
		{Label: "Providers", Path: "../"},
		{Label: "OpenAI", Path: ""},
	}

	assert.Equal(t, expected, result)
}

func TestProviderModelBreadcrumb(t *testing.T) {
	g := &Generator{}

	tests := []struct {
		name         string
		providerName string
		modelName    string
		modelID      string
		expectedLen  int
	}{
		{
			name:         "simple model ID",
			providerName: "OpenAI",
			modelName:    "GPT-4",
			modelID:      "gpt-4",
			expectedLen:  4,
		},
		{
			name:         "model ID with subdirectory",
			providerName: "Groq",
			modelName:    "GPT OSS 120B",
			modelID:      "openai/gpt-oss-120b",
			expectedLen:  4,
		},
		{
			name:         "model ID with multiple subdirectories",
			providerName: "Provider",
			modelName:    "Model",
			modelID:      "org/family/model",
			expectedLen:  4,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.providerModelBreadcrumb(tt.providerName, tt.modelName, tt.modelID)
			assert.Len(t, result, tt.expectedLen)
			assert.Equal(t, "Catalog", result[0].Label)
			assert.Equal(t, "Providers", result[1].Label)
			assert.Equal(t, tt.providerName, result[2].Label)
			assert.Equal(t, tt.modelName, result[3].Label)
			assert.Empty(t, result[3].Path) // Last item should have empty path
		})
	}
}

func TestAuthorBreadcrumb(t *testing.T) {
	g := &Generator{}

	result := g.authorBreadcrumb("OpenAI")

	expected := []Breadcrumb{
		{Label: "Catalog", Path: "../../"},
		{Label: "Authors", Path: "../"},
		{Label: "OpenAI", Path: ""},
	}

	assert.Equal(t, expected, result)
}

func TestAuthorModelBreadcrumb(t *testing.T) {
	g := &Generator{}

	tests := []struct {
		name       string
		authorName string
		modelName  string
		modelID    string
		expectedLen int
	}{
		{
			name:       "simple model ID",
			authorName: "OpenAI",
			modelName:  "GPT-4",
			modelID:    "gpt-4",
			expectedLen: 4,
		},
		{
			name:       "model ID with subdirectory",
			authorName: "Meta",
			modelName:  "Llama 3",
			modelID:    "meta/llama-3",
			expectedLen: 4,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.authorModelBreadcrumb(tt.authorName, tt.modelName, tt.modelID)
			assert.Len(t, result, tt.expectedLen)
			assert.Equal(t, "Catalog", result[0].Label)
			assert.Equal(t, "Authors", result[1].Label)
			assert.Equal(t, tt.authorName, result[2].Label)
			assert.Equal(t, tt.modelName, result[3].Label)
		})
	}
}

func TestFooterGenerators(t *testing.T) {
	g := &Generator{}

	t.Run("catalogFooter", func(t *testing.T) {
		result := g.catalogFooter()
		assert.Contains(t, result, "Generated by [Starmap]")
		assert.NotContains(t, result, "Back to")
	})

	t.Run("providerIndexFooter", func(t *testing.T) {
		result := g.providerIndexFooter()
		assert.Contains(t, result, "Back to Catalog")
		assert.Contains(t, result, "../")
	})

	t.Run("providerFooter", func(t *testing.T) {
		result := g.providerFooter()
		assert.Contains(t, result, "Back to Providers")
		assert.Contains(t, result, "Back to Catalog")
	})

	t.Run("authorIndexFooter", func(t *testing.T) {
		result := g.authorIndexFooter()
		assert.Contains(t, result, "Back to Catalog")
		assert.Contains(t, result, "../")
	})

	t.Run("authorFooter", func(t *testing.T) {
		result := g.authorFooter()
		assert.Contains(t, result, "Back to Authors")
		assert.Contains(t, result, "Back to Catalog")
	})

	t.Run("modelIndexFooter", func(t *testing.T) {
		result := g.modelIndexFooter()
		assert.Contains(t, result, "Back to Catalog")
		assert.Contains(t, result, "../")
	})
}

func TestBuildProviderCrossReferences(t *testing.T) {
	g := &Generator{}

	result := g.buildProviderCrossReferences("openai")

	assert.Len(t, result, 3)
	assert.Equal(t, "All Providers", result[0].Label)
	assert.Equal(t, "../", result[0].Path)
	assert.Equal(t, "Browse by Author", result[1].Label)
	assert.Equal(t, "../../authors/", result[1].Path)
	assert.Equal(t, "Model Comparison", result[2].Label)
	assert.Equal(t, "../../models/", result[2].Path)
}

func TestBuildAuthorCrossReferences(t *testing.T) {
	g := &Generator{}

	result := g.buildAuthorCrossReferences("openai")

	assert.Len(t, result, 3)
	assert.Equal(t, "All Authors", result[0].Label)
	assert.Equal(t, "../", result[0].Path)
	assert.Equal(t, "Browse by Provider", result[1].Label)
	assert.Equal(t, "../../providers/", result[1].Path)
	assert.Equal(t, "Model Comparison", result[2].Label)
	assert.Equal(t, "../../models/", result[2].Path)
}

func TestBuildModelCrossReferences(t *testing.T) {
	g := &Generator{}

	tests := []struct {
		name     string
		context  string
		depth    int
		expected int
	}{
		{
			name:     "provider context",
			context:  "provider",
			depth:    4,
			expected: 2,
		},
		{
			name:     "author context",
			context:  "author",
			depth:    4,
			expected: 2,
		},
		{
			name:     "other context",
			context:  "other",
			depth:    3,
			expected: 2,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := g.buildModelCrossReferences(tt.context, tt.depth)
			assert.Len(t, result, tt.expected)
			assert.Equal(t, "All Providers", result[0].Label)
			assert.Equal(t, "Back to Catalog", result[1].Label)
		})
	}
}