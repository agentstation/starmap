package docs

import (
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/agentstation/utc"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/agentstation/starmap/pkg/catalogs"
)

func TestGenerateProviderDocs(t *testing.T) {
	// Create temp directory
	tempDir := t.TempDir()

	// Create test catalog
	catalog := createTestCatalogWithProviders()

	// Create generator
	g := New(WithOutputDir(tempDir))

	// Generate provider documentation
	err := g.generateProviderDocs(filepath.Join(tempDir, "catalog", "providers"), catalog)
	require.NoError(t, err)

	// Check that directories were created
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "providers"))
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "providers", "openai"))
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "providers", "anthropic"))

	// Check that README files were created
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "providers", "README.md"))
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "providers", "openai", "README.md"))
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "providers", "anthropic", "README.md"))

	// Check that models directories were created
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "providers", "openai", "models"))
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "providers", "anthropic", "models"))
}

func TestGenerateProviderIndex(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogWithProviders()
	g := New()

	providers := catalog.Providers().List()
	// Convert to pointer slice
	providerPointers := make([]*catalogs.Provider, len(providers))
	for i := range providers {
		providerPointers[i] = &providers[i]
	}
	err := g.generateProviderIndex(tempDir, providerPointers)
	require.NoError(t, err)

	// Read the generated index
	indexPath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(indexPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check for expected content
	assert.Contains(t, contentStr, "# üè¢ AI Model Providers")
	assert.Contains(t, contentStr, "## Provider Comparison")
	assert.Contains(t, contentStr, "| Provider | Models | Free Tier | API Key Required | Status Page |")

	// Check for provider entries
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "Anthropic")

	// Check for top models section
	assert.Contains(t, contentStr, "## üåü Top Models Across Providers")
	assert.Contains(t, contentStr, "## Provider Details")

	// Check footer
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGenerateProviderReadme(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogWithProviders()
	g := New()

	// Get a provider from the catalog
	provider, found := catalog.Providers().Get(catalogs.ProviderIDOpenAI)
	require.True(t, found)

	// Generate the provider README
	err := g.generateProviderReadme(tempDir, provider, catalog)
	require.NoError(t, err)

	// Read the generated README
	readmePath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(readmePath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check for expected sections
	assert.Contains(t, contentStr, "# <img src=")
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "## Provider Information")
	assert.Contains(t, contentStr, "| Field | Value |")

	// Check for models section
	assert.Contains(t, contentStr, "## Available Models")

	// Check for configuration section
	assert.Contains(t, contentStr, "## Configuration")
	assert.Contains(t, contentStr, "### Using with Starmap")

	// Check for navigation
	assert.Contains(t, contentStr, "### See Also")
	assert.Contains(t, contentStr, "[All Providers]")

	// Check footer
	assert.Contains(t, contentStr, "Back to Providers")
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGenerateProviderModelPages(t *testing.T) {
	tempDir := t.TempDir()
	modelsDir := filepath.Join(tempDir, "models")
	catalog := createTestCatalogWithProviders()
	g := New()

	// Get a provider
	provider, found := catalog.Providers().Get(catalogs.ProviderIDOpenAI)
	require.True(t, found)

	// Generate model pages
	err := g.generateProviderModelPages(modelsDir, provider, catalog)
	require.NoError(t, err)

	// Check that models directory was created
	assert.DirExists(t, modelsDir)

	// Check that model files were created
	for modelID := range provider.Models {
		modelPath, err := getModelFilePath(modelsDir, modelID)
		require.NoError(t, err)
		assert.FileExists(t, modelPath)
	}
}

func TestGenerateProviderModelPage(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogWithProviders()
	g := New()

	// Get a provider and model
	provider, found := catalog.Providers().Get(catalogs.ProviderIDOpenAI)
	require.True(t, found)

	model, err := catalog.FindModel("gpt-4")
	require.NoError(t, err)

	// Get author map
	authorMap := make(map[catalogs.AuthorID]*catalogs.Author)
	for _, author := range catalog.Authors().List() {
		authorMap[author.ID] = &author
	}

	// Generate the model page
	modelPath := filepath.Join(tempDir, "gpt-4.md")
	err = g.generateProviderModelPage(modelPath, &model, provider, authorMap)
	require.NoError(t, err)

	// Check that the file was created
	assert.FileExists(t, modelPath)

	// Read the generated content
	content, err := os.ReadFile(modelPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check for expected content
	assert.Contains(t, contentStr, "# GPT-4")

	// Check breadcrumb
	assert.Contains(t, contentStr, "Catalog")
	assert.Contains(t, contentStr, "Providers")
	assert.Contains(t, contentStr, "**GPT-4**")

	// Check overview section
	assert.Contains(t, contentStr, "## üìã Overview")
	assert.Contains(t, contentStr, "- **ID**: `gpt-4`")
	assert.Contains(t, contentStr, "- **Provider**: [OpenAI]")

	// Check capabilities
	assert.Contains(t, contentStr, "## üéØ Capabilities")

	// Check modality tables
	assert.Contains(t, contentStr, "### Input/Output Modalities")
	assert.Contains(t, contentStr, "| Direction | Text | Image | Audio | Video | PDF |")

	// Check navigation
	assert.Contains(t, contentStr, "### Navigation")
	assert.Contains(t, contentStr, "More models by OpenAI")

	// Check footer
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGetProviderDescription(t *testing.T) {
	tests := []struct {
		name     string
		provider *catalogs.Provider
		expected string
	}{
		{
			name: "OpenAI",
			provider: &catalogs.Provider{
				ID:   catalogs.ProviderIDOpenAI,
				Name: "OpenAI",
			},
			expected: "Industry-leading AI models including GPT-4 and DALL-E, pioneering AGI research.",
		},
		{
			name: "Anthropic",
			provider: &catalogs.Provider{
				ID:   catalogs.ProviderIDAnthropic,
				Name: "Anthropic",
			},
			expected: "Creator of Claude, focusing on safe and beneficial AI with constitutional training.",
		},
		{
			name: "Unknown provider",
			provider: &catalogs.Provider{
				ID:   catalogs.ProviderID("unknown"),
				Name: "Unknown",
			},
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getProviderDescription(tt.provider)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGroupModelsByFamily(t *testing.T) {
	models := []*catalogs.Model{
		{
			ID:   "gpt-4",
			Name: "GPT-4",
		},
		{
			ID:   "gpt-3.5-turbo",
			Name: "GPT-3.5 Turbo",
		},
		{
			ID:   "claude-3-opus",
			Name: "Claude 3 Opus",
		},
		{
			ID:   "claude-3-sonnet",
			Name: "Claude 3 Sonnet",
		},
		{
			ID:   "llama-3-70b",
			Name: "Llama 3 70B",
		},
	}

	result := groupModelsByFamily(models)

	// Check that families were created
	assert.NotEmpty(t, result)

	// Check for expected families
	_, hasGPT := result["GPT"]
	assert.True(t, hasGPT)

	_, hasClaude := result["Claude"]
	assert.True(t, hasClaude)

	_, hasLlama := result["Llama"]
	assert.True(t, hasLlama)

	// Check model counts
	assert.Len(t, result["GPT"], 2)
	assert.Len(t, result["Claude"], 2)
	assert.Len(t, result["Llama"], 1)
}

// Helper functions.
func intPtr(i int) *int                          { return &i }
func int64Ptr(i int64) *int64                    { return &i }
func boolPtr(b bool) *bool                       { return &b }
func durationPtr(d time.Duration) *time.Duration { return &d }

// Helper function to create test catalog with providers.
func createTestCatalogWithProviders() catalogs.Reader {
	catalog, _ := catalogs.New()

	// Add authors
	openai := catalogs.Author{
		ID:   catalogs.AuthorIDOpenAI,
		Name: "OpenAI",
	}
	anthropic := catalogs.Author{
		ID:   catalogs.AuthorIDAnthropic,
		Name: "Anthropic",
	}
	catalog.SetAuthor(openai)
	catalog.SetAuthor(anthropic)

	// Add models
	gpt4 := catalogs.Model{
		ID:      "gpt-4",
		Name:    "GPT-4",
		Authors: []catalogs.Author{{ID: catalogs.AuthorIDOpenAI, Name: "OpenAI"}},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
			ToolCalls: true,
			Streaming: true,
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 8192,
			OutputTokens:  4096,
		},
		Pricing: &catalogs.ModelPricing{
			Tokens: &catalogs.ModelTokenPricing{
				Input:  &catalogs.ModelTokenCost{Per1M: 30.0},
				Output: &catalogs.ModelTokenCost{Per1M: 60.0},
			},
		},
	}

	claude := catalogs.Model{
		ID:   "claude-3-opus",
		Name: "Claude 3 Opus",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDAnthropic, Name: "Anthropic"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText, catalogs.ModelModalityImage},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
			ToolCalls: true,
			Streaming: true,
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 200000,
			OutputTokens:  4096,
		},
		Pricing: &catalogs.ModelPricing{
			Tokens: &catalogs.ModelTokenPricing{
				Input:  &catalogs.ModelTokenCost{Per1M: 15.0},
				Output: &catalogs.ModelTokenCost{Per1M: 75.0},
			},
		},
	}

	// Add providers with models
	openaiProvider := catalogs.Provider{
		ID:   catalogs.ProviderIDOpenAI,
		Name: "OpenAI",
		Models: map[string]*catalogs.Model{
			"gpt-4": &gpt4,
		},
	}

	anthropicProvider := catalogs.Provider{
		ID:   catalogs.ProviderIDAnthropic,
		Name: "Anthropic",
		Models: map[string]*catalogs.Model{
			"claude-3-opus": &claude,
		},
	}

	catalog.SetProvider(openaiProvider)
	catalog.SetProvider(anthropicProvider)

	return catalog
}

func TestGenerateProviderReadmeEdgeCasesOriginal(t *testing.T) {
	tests := []struct {
		name     string
		provider *catalogs.Provider
		verify   func(t *testing.T, content string)
	}{
		{
			name: "provider with no models",
			provider: &catalogs.Provider{
				ID:     catalogs.ProviderIDGroq,
				Name:   "Groq",
				Models: map[string]*catalogs.Model{},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "# <img src=")
				assert.Contains(t, content, "Groq")
				assert.Contains(t, content, "## Available Models")
				assert.Contains(t, content, "No models currently available")
			},
		},
		{
			name: "provider with API key config",
			provider: &catalogs.Provider{
				ID:   catalogs.ProviderIDOpenAI,
				Name: "OpenAI",
				Models: map[string]*catalogs.Model{
					"gpt-4": {ID: "gpt-4", Name: "GPT-4"},
				},
				APIKey: &catalogs.ProviderAPIKey{
					Name:   "api_key",
					Header: "Authorization",
					Scheme: "Bearer",
				},
				EnvVars: []catalogs.ProviderEnvVar{{Name: "OPENAI_API_KEY"}},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "## Configuration")
				// API key is shown as "api_key" in actual output
				assert.Contains(t, content, "api_key")
				assert.Contains(t, content, "export api_key")
			},
		},
		{
			name: "provider with status page",
			provider: &catalogs.Provider{
				ID:     catalogs.ProviderIDAnthropic,
				Name:   "Anthropic",
				Models: map[string]*catalogs.Model{},
				StatusPageURL: func() *string {
					s := "https://status.anthropic.com"
					return &s
				}(),
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "| **Status Page** |")
				assert.Contains(t, content, "https://status.anthropic.com")
			},
		},
		{
			name: "provider with catalog endpoints",
			provider: &catalogs.Provider{
				ID:     "endpoint-provider",
				Name:   "Endpoint Provider",
				Models: map[string]*catalogs.Model{},
				Catalog: &catalogs.ProviderCatalog{
					Docs: stringPtr("https://docs.example.com/api"),
					Endpoint: catalogs.ProviderEndpoint{
						URL: "https://api.example.com/v1/models",
					},
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "API Endpoints")
				assert.Contains(t, content, "Documentation")
				assert.Contains(t, content, "https://docs.example.com/api")
				assert.Contains(t, content, "Models API")
				assert.Contains(t, content, "https://api.example.com/v1/models")
			},
		},
		{
			name: "provider with chat completions endpoint",
			provider: &catalogs.Provider{
				ID:     "chat-provider",
				Name:   "Chat Provider",
				Models: map[string]*catalogs.Model{},
				ChatCompletions: &catalogs.ProviderChatCompletions{
					URL: stringPtr("https://api.example.com/v1/chat/completions"),
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "API Endpoints")
				assert.Contains(t, content, "Chat Completions")
				assert.Contains(t, content, "https://api.example.com/v1/chat/completions")
			},
		},
		{
			name: "provider with endpoints",
			provider: &catalogs.Provider{
				ID:     catalogs.ProviderIDCerebras,
				Name:   "Cerebras",
				Models: map[string]*catalogs.Model{},
				ChatCompletions: &catalogs.ProviderChatCompletions{
					URL: func() *string {
						s := "https://api.cerebras.ai/v1/chat/completions"
						return &s
					}(),
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "API Endpoints")
				assert.Contains(t, content, "Chat Completions")
				assert.Contains(t, content, "https://api.cerebras.ai/v1/chat/completions")
			},
		},
		{
			name: "provider with privacy policy",
			provider: &catalogs.Provider{
				ID:     "privacy-provider",
				Name:   "Privacy Provider",
				Models: map[string]*catalogs.Model{},
				PrivacyPolicy: &catalogs.ProviderPrivacyPolicy{
					PrivacyPolicyURL:  stringPtr("https://privacy.example.com"),
					TermsOfServiceURL: stringPtr("https://terms.example.com"),
					RetainsData:       boolPtr(true),
					TrainsOnData:      boolPtr(false),
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "Privacy & Data Handling")
				assert.Contains(t, content, "Privacy Policy")
				assert.Contains(t, content, "https://privacy.example.com")
				assert.Contains(t, content, "Terms of Service")
				assert.Contains(t, content, "https://terms.example.com")
				assert.Contains(t, content, "Retains User Data")
				assert.Contains(t, content, "Yes")
				assert.Contains(t, content, "Trains on User Data")
				assert.Contains(t, content, "No")
			},
		},
		{
			name: "provider with retention policy",
			provider: &catalogs.Provider{
				ID:     "retention-provider",
				Name:   "Retention Provider",
				Models: map[string]*catalogs.Model{},
				RetentionPolicy: &catalogs.ProviderRetentionPolicy{
					Type:     catalogs.ProviderRetentionTypeFixed,
					Duration: durationPtr(30 * 24 * time.Hour),
					Details:  stringPtr("Data retained for 30 days for service improvement"),
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "Data Retention")
				assert.Contains(t, content, "Fixed Duration")
				assert.Contains(t, content, "30 days")
				assert.Contains(t, content, "Data retained for 30 days for service improvement")
			},
		},
		{
			name: "provider with governance policy",
			provider: &catalogs.Provider{
				ID:     "governance-provider",
				Name:   "Governance Provider",
				Models: map[string]*catalogs.Model{},
				GovernancePolicy: &catalogs.ProviderGovernancePolicy{
					ModerationRequired: boolPtr(true),
					Moderated:          boolPtr(true),
					Moderator:          stringPtr("automated + human review"),
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "Content Moderation")
				assert.Contains(t, content, "Requires Moderation")
				assert.Contains(t, content, "Yes")
				assert.Contains(t, content, "Automated + Human Review")
			},
		},
		{
			name: "provider with health components",
			provider: &catalogs.Provider{
				ID:     "health-provider",
				Name:   "Health Provider",
				Models: map[string]*catalogs.Model{},
				ChatCompletions: &catalogs.ProviderChatCompletions{
					URL:          stringPtr("https://api.example.com/v1/chat"),
					HealthAPIURL: stringPtr("https://status.example.com/api"),
					HealthComponents: []catalogs.ProviderHealthComponent{
						{ID: "api", Name: "API Service"},
						{ID: "models", Name: "Model Service"},
					},
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "Health API")
				assert.Contains(t, content, "https://status.example.com/api")
				// Note: Health components are not currently rendered in the README
			},
		},
		{
			name: "provider with all features",
			provider: &catalogs.Provider{
				ID:   catalogs.ProviderIDGoogleVertex,
				Name: "Google Vertex",
				Models: map[string]*catalogs.Model{
					"gemini-pro": {ID: "gemini-pro", Name: "Gemini Pro"},
				},
				APIKey: &catalogs.ProviderAPIKey{
					Name:   "api_key",
					Header: "X-API-Key",
				},
				EnvVars: []catalogs.ProviderEnvVar{
					{Name: "GOOGLE_API_KEY"},
				},
				StatusPageURL: func() *string {
					s := "https://status.cloud.google.com"
					return &s
				}(),
				ChatCompletions: &catalogs.ProviderChatCompletions{
					URL: func() *string {
						s := "https://generativelanguage.googleapis.com/v1/models"
						return &s
					}(),
				},
			},
			verify: func(t *testing.T, content string) {
				assert.Contains(t, content, "Google Vertex")
				assert.Contains(t, content, "## Available Models")
				assert.Contains(t, content, "Gemini Pro")
				assert.Contains(t, content, "## Configuration")
				assert.Contains(t, content, "api_key") // Actual in output
				assert.Contains(t, content, "API Endpoints")
				assert.Contains(t, content, "https://status.cloud.google.com")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tempDir := t.TempDir()
			catalog, _ := catalogs.New()

			// Add the provider to catalog (it already has models in its Models map)
			catalog.SetProvider(*tt.provider)

			g := New()
			err := g.generateProviderReadme(tempDir, tt.provider, catalog)
			require.NoError(t, err)

			// Read and verify content
			content, err := os.ReadFile(filepath.Join(tempDir, "README.md"))
			require.NoError(t, err)

			tt.verify(t, string(content))
		})
	}
}

func TestGenerateProviderIndexWithVariousProviders(t *testing.T) {
	tempDir := t.TempDir()
	catalog, _ := catalogs.New()

	// Add various types of providers
	providers := []*catalogs.Provider{
		{
			ID:   catalogs.ProviderIDOpenAI,
			Name: "OpenAI",
			EnvVars: []catalogs.ProviderEnvVar{
				{Name: "OPENAI_API_KEY"},
			},
			StatusPageURL: func() *string {
				s := "https://status.openai.com"
				return &s
			}(),
			Models: map[string]*catalogs.Model{
				"gpt-4": {ID: "gpt-4", Name: "GPT-4"},
			},
		},
		{
			ID:   catalogs.ProviderIDGroq,
			Name: "Groq",
			Models: map[string]*catalogs.Model{
				"llama-3-70b": {ID: "llama-3-70b", Name: "Llama 3 70B"},
			},
		},
		{
			ID:     catalogs.ProviderIDCerebras,
			Name:   "Cerebras",
			Models: map[string]*catalogs.Model{},
		},
	}

	for _, p := range providers {
		// Provider already has models in its Models map
		catalog.SetProvider(*p)
	}

	g := New()
	err := g.generateProviderIndex(tempDir, providers)
	require.NoError(t, err)

	content, err := os.ReadFile(filepath.Join(tempDir, "README.md"))
	require.NoError(t, err)
	contentStr := string(content)

	// Verify all providers are listed
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "Groq")
	assert.Contains(t, contentStr, "Cerebras")

	// Verify status page links
	assert.Contains(t, contentStr, "[Status](https://status.openai.com)")

	// Verify provider names appear in table
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "Groq")
	assert.Contains(t, contentStr, "Cerebras")
}

func TestGenerateProviderModelPageWithComplexModel(t *testing.T) {
	tempDir := t.TempDir()
	catalog, _ := catalogs.New()
	g := New()

	// Create a complex model with all features
	complexModel := catalogs.Model{
		ID:   "complex-model",
		Name: "Complex Model",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDOpenAI, Name: "OpenAI"},
			{ID: catalogs.AuthorIDAnthropic, Name: "Anthropic"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText, catalogs.ModelModalityImage, catalogs.ModelModalityAudio},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText, catalogs.ModelModalityImage},
			},
			ToolCalls:       true,
			Tools:           true,
			ToolChoice:      true,
			Streaming:       true,
			WebSearch:       true,
			Attachments:     true,
			Reasoning:       true,
			ReasoningEffort: true,
			ReasoningTokens: true,
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 200000,
			OutputTokens:  8192,
		},
		Pricing: &catalogs.ModelPricing{
			Tokens: &catalogs.ModelTokenPricing{
				Input: &catalogs.ModelTokenCost{
					Per1M: 15.0,
				},
				Output: &catalogs.ModelTokenCost{
					Per1M: 60.0,
				},
				Cache: &catalogs.ModelTokenCachePricing{
					Write: &catalogs.ModelTokenCost{
						Per1M: 3.75,
					},
					Read: &catalogs.ModelTokenCost{
						Per1M: 1.5,
					},
				},
			},
			Currency: "USD",
		},
		Metadata: &catalogs.ModelMetadata{
			ReleaseDate: utc.Time{}, // Would need proper date initialization
			OpenWeights: false,
			Tags:        []catalogs.ModelTag{"multimodal", "enterprise", "research"},
		},
	}

	provider := catalogs.Provider{
		ID:   catalogs.ProviderIDOpenAI,
		Name: "OpenAI",
		Models: map[string]*catalogs.Model{
			complexModel.ID: &complexModel,
		},
	}

	catalog.SetProvider(provider)
	catalog.SetAuthor(catalogs.Author{ID: catalogs.AuthorIDOpenAI, Name: "OpenAI"})
	catalog.SetAuthor(catalogs.Author{ID: catalogs.AuthorIDAnthropic, Name: "Anthropic"})

	// Create author map
	authorMap := make(map[catalogs.AuthorID]*catalogs.Author)
	for _, author := range catalog.Authors().List() {
		authorMap[author.ID] = &author
	}

	modelPath := filepath.Join(tempDir, "complex-model.md")
	err := g.generateProviderModelPage(modelPath, &complexModel, &provider, authorMap)
	require.NoError(t, err)

	content, err := os.ReadFile(modelPath)
	require.NoError(t, err)
	contentStr := string(content)

	// Verify all features are documented
	assert.Contains(t, contentStr, "Complex Model")
	assert.Contains(t, contentStr, "OpenAI") // Authors are linked separately
	assert.Contains(t, contentStr, "Anthropic")
	// Check for feature badges instead of checkmarks
	assert.Contains(t, contentStr, "tool")
	assert.Contains(t, contentStr, "streaming")
	assert.Contains(t, contentStr, "web")
	assert.Contains(t, contentStr, "attachments")
	assert.Contains(t, contentStr, "reasoning")

	// Verify pricing details
	assert.Contains(t, contentStr, "$15.00")
	assert.Contains(t, contentStr, "$60.00")
	assert.Contains(t, contentStr, "Cache")
	assert.Contains(t, contentStr, "$3.75")
	assert.Contains(t, contentStr, "$1.50")

	// Verify limits - formatted as 200k, 8k
	assert.Contains(t, contentStr, "200k")
	assert.Contains(t, contentStr, "8k")

	// Verify metadata - check for tag
	assert.Contains(t, contentStr, "Multimodal")
}

func TestGenerateProviderDocsWithEmptyCatalog(t *testing.T) {
	tempDir := t.TempDir()
	catalog, _ := catalogs.New()
	g := New(WithOutputDir(tempDir))

	// Try to generate with empty catalog
	err := g.generateProviderDocs(filepath.Join(tempDir, "catalog", "providers"), catalog)
	require.NoError(t, err)

	// Should create directory structure even with no providers
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "providers"))
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "providers", "README.md"))

	// Read index content
	content, err := os.ReadFile(filepath.Join(tempDir, "catalog", "providers", "README.md"))
	require.NoError(t, err)

	// Should have basic structure
	assert.Contains(t, string(content), "# üè¢ AI Model Providers")
}

func TestGenerateProviderModelPagesWithNoModels(t *testing.T) {
	tempDir := t.TempDir()
	modelsDir := filepath.Join(tempDir, "models")
	catalog, _ := catalogs.New()
	g := New()

	// Provider with no models
	provider := catalogs.Provider{
		ID:     catalogs.ProviderIDGroq,
		Name:   "Groq",
		Models: map[string]*catalogs.Model{},
	}

	catalog.SetProvider(provider)

	// Should not error even with no models
	err := g.generateProviderModelPages(modelsDir, &provider, catalog)
	require.NoError(t, err)

	// Models directory might not be created if no models
	// Just check that no error occurred
}

// TestGenerateProviderReadmeEdgeCases tests edge cases for generateProviderReadme.
func TestGenerateProviderReadmeEdgeCases(t *testing.T) {
	tests := []struct {
		name     string
		provider *catalogs.Provider
		contains []string
	}{
		{
			name: "provider with API key env var",
			provider: &catalogs.Provider{
				ID:   catalogs.ProviderIDOpenAI,
				Name: "OpenAI",
				APIKey: &catalogs.ProviderAPIKey{
					Name:    "OPENAI_API_KEY",
					Pattern: "sk-*",
					Header:  "Authorization",
					Scheme:  "Bearer",
				},
			},
			contains: []string{
				"OPENAI_API_KEY",
			},
		},
		{
			name: "provider with status page",
			provider: &catalogs.Provider{
				ID:            "test-provider",
				Name:          "Test Provider",
				StatusPageURL: stringPtr("https://status.example.com"),
			},
			contains: []string{
				"Test Provider",
				"https://status.example.com",
			},
		},
		{
			name: "provider with no models",
			provider: &catalogs.Provider{
				ID:     "empty-provider",
				Name:   "Empty Provider",
				Models: map[string]*catalogs.Model{},
			},
			contains: []string{
				"Empty Provider",
				"No models currently available",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			providerDir := filepath.Join(tmpDir, string(tt.provider.ID))
			err := os.MkdirAll(providerDir, 0755)
			require.NoError(t, err)

			// Create catalog with provider
			catalog, err := catalogs.New()
			require.NoError(t, err)
			err = catalog.SetProvider(*tt.provider)
			require.NoError(t, err)

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate provider readme
			err = gen.generateProviderReadme(providerDir, tt.provider, catalog)
			require.NoError(t, err)

			// Check README exists
			readmePath := filepath.Join(providerDir, "README.md")
			assert.FileExists(t, readmePath)

			// Check content
			content, err := os.ReadFile(readmePath)
			require.NoError(t, err)
			contentStr := string(content)

			for _, expected := range tt.contains {
				assert.Contains(t, contentStr, expected, "Should contain: %s", expected)
			}
		})
	}
}

// TestGenerateProviderDocsComprehensive tests the generateProviderDocs function comprehensively.
func TestGenerateProviderDocsComprehensive(t *testing.T) {
	tests := []struct {
		name      string
		providers []catalogs.Provider
		models    []catalogs.Model
		checkFunc func(t *testing.T, outputDir string)
	}{
		{
			name:      "empty provider list",
			providers: []catalogs.Provider{},
			models:    []catalogs.Model{},
			checkFunc: func(t *testing.T, outputDir string) {
				// Index should still be created
				indexPath := filepath.Join(outputDir, "README.md")
				assert.FileExists(t, indexPath)
			},
		},
		{
			name: "providers with no models",
			providers: []catalogs.Provider{
				{
					ID:     "provider1",
					Name:   "Provider 1",
					Models: map[string]*catalogs.Model{},
				},
				{
					ID:     "provider2",
					Name:   "Provider 2",
					Models: map[string]*catalogs.Model{},
				},
			},
			models: []catalogs.Model{},
			checkFunc: func(t *testing.T, outputDir string) {
				// Check directories created
				assert.DirExists(t, filepath.Join(outputDir, "provider1"))
				assert.DirExists(t, filepath.Join(outputDir, "provider2"))
			},
		},
		{
			name: "providers with models",
			providers: []catalogs.Provider{
				{
					ID:   "test-provider",
					Name: "Test Provider",
					Models: map[string]*catalogs.Model{
						"model-1": {
							ID:   "model-1",
							Name: "Model 1",
						},
					},
				},
			},
			models: []catalogs.Model{
				{
					ID:   "model-1",
					Name: "Model 1",
				},
			},
			checkFunc: func(t *testing.T, outputDir string) {
				// Check provider directory
				assert.DirExists(t, filepath.Join(outputDir, "test-provider"))
				// Check models directory
				assert.DirExists(t, filepath.Join(outputDir, "test-provider", "models"))
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			providersDir := filepath.Join(tmpDir, "providers")

			// Create catalog
			catalog, err := catalogs.New()
			require.NoError(t, err)

			// Add providers with models
			for i, provider := range tt.providers {
				// Add models to the provider
				if provider.Models == nil {
					provider.Models = make(map[string]*catalogs.Model)
				}
				// Distribute models among providers
				for j, model := range tt.models {
					if j%len(tt.providers) == i {
						provider.Models[model.ID] = &model
					}
				}
				err := catalog.SetProvider(provider)
				require.NoError(t, err)
			}

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate provider docs
			err = gen.generateProviderDocs(providersDir, catalog)
			require.NoError(t, err)

			if tt.checkFunc != nil {
				tt.checkFunc(t, providersDir)
			}
		})
	}
}

// TestGenerateWithErrors tests error handling.
func TestGenerateWithErrors(t *testing.T) {
	t.Run("index write failure", func(t *testing.T) {
		tmpDir := t.TempDir()
		providersDir := filepath.Join(tmpDir, "providers")
		err := os.MkdirAll(providersDir, 0755)
		require.NoError(t, err)

		// Make directory read-only
		err = os.Chmod(providersDir, 0555)
		require.NoError(t, err)
		defer os.Chmod(providersDir, 0755)

		catalog, err := catalogs.New()
		require.NoError(t, err)

		gen := &Generator{
			outputDir: tmpDir,
			verbose:   false,
		}

		err = gen.generateProviderDocs(providersDir, catalog)
		assert.Error(t, err)
	})
}

// TestGenerateVerboseMode tests verbose mode logging.
func TestGenerateVerboseMode(t *testing.T) {
	tmpDir := t.TempDir()
	catalog, err := catalogs.New()
	require.NoError(t, err)

	// Add a provider
	provider := catalogs.Provider{
		ID:     "test",
		Name:   "Test Provider",
		Models: map[string]*catalogs.Model{},
	}
	err = catalog.SetProvider(provider)
	require.NoError(t, err)

	// Create generator with verbose mode
	gen := &Generator{
		outputDir: tmpDir,
		verbose:   true,
	}

	// Generate provider docs - should not error
	err = gen.generateProviderDocs(filepath.Join(tmpDir, "providers"), catalog)
	require.NoError(t, err)
}

// TestGenerateProviderModelPageComplex tests generateProviderModelPage with complex scenarios.
func TestGenerateProviderModelPageComplex(t *testing.T) {
	tests := []struct {
		name     string
		provider *catalogs.Provider
		model    *catalogs.Model
		contains []string
	}{
		{
			name: "model with full features",
			provider: &catalogs.Provider{
				ID:   "test-provider",
				Name: "Test Provider",
			},
			model: &catalogs.Model{
				ID:          "model-1",
				Name:        "Model 1",
				Description: "A test model with all features",
				Features: &catalogs.ModelFeatures{
					Tools:     true,
					ToolCalls: true,
					Modalities: catalogs.ModelModalities{
						Input: []catalogs.ModelModality{
							catalogs.ModelModalityText,
							catalogs.ModelModalityImage,
						},
						Output: []catalogs.ModelModality{
							catalogs.ModelModalityText,
						},
					},
				},
				Limits: &catalogs.ModelLimits{
					ContextWindow: 128000,
					OutputTokens:  4096,
				},
			},
			contains: []string{
				"Model 1",
				"Test Provider",
				"test model with all features",
				"Tool Definitions",
				"128k",
				"4k",
			},
		},
		{
			name: "model with pricing",
			provider: &catalogs.Provider{
				ID:   "pricing-provider",
				Name: "Pricing Provider",
			},
			model: &catalogs.Model{
				ID:   "priced-model",
				Name: "Priced Model",
				Pricing: &catalogs.ModelPricing{
					Tokens: &catalogs.ModelTokenPricing{
						Input:  &catalogs.ModelTokenCost{Per1M: 1.0},
						Output: &catalogs.ModelTokenCost{Per1M: 2.0},
					},
				},
			},
			contains: []string{
				"Priced Model",
				"$1.00",
				"$2.00",
			},
		},
		{
			name: "model with attachments",
			provider: &catalogs.Provider{
				ID:   "attachment-provider",
				Name: "Attachment Provider",
			},
			model: &catalogs.Model{
				ID:   "attachment-model",
				Name: "Attachment Model",
				Features: &catalogs.ModelFeatures{
					Attachments: true,
				},
				Attachments: &catalogs.ModelAttachments{
					MimeTypes: []string{
						"text/plain",
						"application/pdf",
					},
					MaxFiles: intPtr(10),
				},
			},
			contains: []string{
				"Attachment Model",
				"text/plain",
				"application/pdf",
			},
		},
		{
			name: "model with multiple authors",
			provider: &catalogs.Provider{
				ID:   "multi-author-provider",
				Name: "Multi Author Provider",
			},
			model: &catalogs.Model{
				ID:   "multi-author-model",
				Name: "Multi Author Model",
				Authors: []catalogs.Author{
					{ID: "author1", Name: "Author 1"},
					{ID: "author2", Name: "Author 2"},
				},
			},
			contains: []string{
				"Multi Author Model",
				"Author 1",
				"Author 2",
			},
		},
		{
			name: "model with tool configuration",
			provider: &catalogs.Provider{
				ID:   "tools-provider",
				Name: "Tools Provider",
			},
			model: &catalogs.Model{
				ID:   "tools-model",
				Name: "Tools Model",
				Features: &catalogs.ModelFeatures{
					Tools:      true,
					ToolCalls:  true,
					ToolChoice: true,
				},
				Tools: &catalogs.ModelTools{
					ToolChoices: []catalogs.ToolChoice{
						catalogs.ToolChoiceAuto,
						catalogs.ToolChoiceNone,
						catalogs.ToolChoiceRequired,
					},
				},
			},
			contains: []string{
				"Tools Model",
				"Tool Configuration",
				"Supported Tool Choices",
				"auto, none, required",
			},
		},
		{
			name: "model with delivery options",
			provider: &catalogs.Provider{
				ID:   "delivery-provider",
				Name: "Delivery Provider",
			},
			model: &catalogs.Model{
				ID:   "delivery-model",
				Name: "Delivery Model",
				Delivery: &catalogs.ModelDelivery{
					Formats: []catalogs.ModelResponseFormat{
						catalogs.ModelResponseFormatJSON,
						catalogs.ModelResponseFormatText,
						catalogs.ModelResponseFormatFunctionCall,
					},
					Streaming: []catalogs.ModelStreaming{
						catalogs.ModelStreamingSSE,
						catalogs.ModelStreamingChunked,
					},
					Protocols: []catalogs.ModelResponseProtocol{
						catalogs.ModelResponseProtocolHTTP,
						catalogs.ModelResponseProtocolWebSocket,
					},
				},
			},
			contains: []string{
				"Delivery Model",
				"Response Delivery Options",
				"Response Formats",
				"json, text, function_call",
				"Streaming Modes",
				"sse, chunked",
				"Protocols",
				"http, websocket",
			},
		},
		{
			name: "model with complete attachments",
			provider: &catalogs.Provider{
				ID:   "full-attachments-provider",
				Name: "Full Attachments Provider",
			},
			model: &catalogs.Model{
				ID:   "full-attachments-model",
				Name: "Full Attachments Model",
				Features: &catalogs.ModelFeatures{
					Attachments: true,
				},
				Attachments: &catalogs.ModelAttachments{
					MimeTypes: []string{
						"image/png",
						"image/jpeg",
						"application/pdf",
						"text/plain",
					},
					MaxFileSize: int64Ptr(10485760), // 10MB
					MaxFiles:    intPtr(5),
				},
			},
			contains: []string{
				"Full Attachments Model",
				"File Attachments",
				"Supported Types",
				"image/png, image/jpeg, application/pdf, text/plain",
				"Max File Size",
				"10.5M bytes",
				"Max Files",
				"5 per request",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			modelsDir := filepath.Join(tmpDir, "models")
			err := os.MkdirAll(modelsDir, 0755)
			require.NoError(t, err)

			// Create catalog
			catalog, err := catalogs.New()
			require.NoError(t, err)

			// Add provider
			err = catalog.SetProvider(*tt.provider)
			require.NoError(t, err)

			// Add model authors if present
			for _, author := range tt.model.Authors {
				err = catalog.SetAuthor(author)
				require.NoError(t, err)
			}

			// Add model to provider
			if tt.provider.Models == nil {
				tt.provider.Models = make(map[string]*catalogs.Model)
			}
			tt.provider.Models[tt.model.ID] = tt.model
			err = catalog.SetProvider(*tt.provider)
			require.NoError(t, err)

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate provider model page
			modelPath := filepath.Join(modelsDir, tt.model.ID+".md")
			authorMap := make(map[catalogs.AuthorID]*catalogs.Author)
			for _, author := range catalog.Authors().List() {
				authorMap[author.ID] = &author
			}
			err = gen.generateProviderModelPage(modelPath, tt.model, tt.provider, authorMap)
			require.NoError(t, err)

			// Check file exists and contains expected content
			assert.FileExists(t, modelPath)

			content, err := os.ReadFile(modelPath)
			require.NoError(t, err)
			contentStr := string(content)

			for _, expected := range tt.contains {
				assert.Contains(t, contentStr, expected, "Should contain: %s", expected)
			}
		})
	}
}

// TestGenerateProviderModelPageEdgeCases tests edge cases for provider model pages.
func TestGenerateProviderModelPageEdgeCases(t *testing.T) {
	tests := []struct {
		name     string
		provider *catalogs.Provider
		model    *catalogs.Model
		contains []string
	}{
		{
			name: "model with minimal data",
			provider: &catalogs.Provider{
				ID:   "minimal-provider",
				Name: "Minimal Provider",
			},
			model: &catalogs.Model{
				ID:   "minimal-model",
				Name: "Minimal Model",
			},
			contains: []string{
				"Minimal Model",
				"Minimal Provider",
			},
		},
		{
			name: "model with reasoning features",
			provider: &catalogs.Provider{
				ID:   "reasoning-provider",
				Name: "Reasoning Provider",
			},
			model: &catalogs.Model{
				ID:   "reasoning-model",
				Name: "Reasoning Model",
				Features: &catalogs.ModelFeatures{
					Reasoning:        true,
					ReasoningEffort:  true,
					IncludeReasoning: true,
				},
			},
			contains: []string{
				"Reasoning Model",
				"Reasoning",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			modelsDir := filepath.Join(tmpDir, "models")
			err := os.MkdirAll(modelsDir, 0755)
			require.NoError(t, err)

			// Create catalog
			catalog, err := catalogs.New()
			require.NoError(t, err)

			// Add provider
			err = catalog.SetProvider(*tt.provider)
			require.NoError(t, err)

			// Add model to provider
			if tt.provider.Models == nil {
				tt.provider.Models = make(map[string]*catalogs.Model)
			}
			tt.provider.Models[tt.model.ID] = tt.model
			err = catalog.SetProvider(*tt.provider)
			require.NoError(t, err)

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate provider model page
			modelPath := filepath.Join(modelsDir, tt.model.ID+".md")
			authorMap := make(map[catalogs.AuthorID]*catalogs.Author)
			for _, author := range catalog.Authors().List() {
				authorMap[author.ID] = &author
			}
			err = gen.generateProviderModelPage(modelPath, tt.model, tt.provider, authorMap)
			require.NoError(t, err)

			// Check file exists and contains expected content
			assert.FileExists(t, modelPath)

			content, err := os.ReadFile(modelPath)
			require.NoError(t, err)
			contentStr := string(content)

			for _, expected := range tt.contains {
				assert.Contains(t, contentStr, expected, "Should contain: %s", expected)
			}
		})
	}
}

// TestGenerateProviderModelPageErrors tests error handling for provider model pages.
func TestGenerateProviderDocsErrorHandling(t *testing.T) {
	t.Run("directory creation failure", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Make directory read-only to prevent subdirectory creation
		err := os.Chmod(tmpDir, 0555)
		require.NoError(t, err)
		defer os.Chmod(tmpDir, 0755)

		catalog, _ := catalogs.New()
		provider := &catalogs.Provider{
			ID:   "test",
			Name: "Test Provider",
		}
		catalog.SetProvider(*provider)

		gen := &Generator{
			outputDir: tmpDir,
		}

		err = gen.generateProviderDocs(tmpDir, catalog)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "permission denied")
	})

	t.Run("readme write failure", func(t *testing.T) {
		tmpDir := t.TempDir()
		providerDir := filepath.Join(tmpDir, "providers", "test")
		err := os.MkdirAll(providerDir, 0755)
		require.NoError(t, err)

		// Create README.md as directory to cause write failure
		readmeFile := filepath.Join(providerDir, "README.md")
		err = os.Mkdir(readmeFile, 0755)
		require.NoError(t, err)

		catalog, _ := catalogs.New()
		provider := &catalogs.Provider{
			ID:   "test",
			Name: "Test Provider",
		}
		catalog.SetProvider(*provider)

		gen := &Generator{
			outputDir: tmpDir,
		}

		err = gen.generateProviderReadme(providerDir, provider, catalog)
		assert.Error(t, err)
	})
}

func TestGenerateProviderModelPageErrors(t *testing.T) {
	t.Run("write failure", func(t *testing.T) {
		tmpDir := t.TempDir()
		modelsDir := filepath.Join(tmpDir, "models")

		// Create a file where the model file would be written
		err := os.MkdirAll(modelsDir, 0755)
		require.NoError(t, err)

		// Make directory read-only
		err = os.Chmod(modelsDir, 0555)
		require.NoError(t, err)
		defer os.Chmod(modelsDir, 0755)

		catalog, err := catalogs.New()
		require.NoError(t, err)

		model := &catalogs.Model{
			ID:   "test-model",
			Name: "Test Model",
		}

		provider := &catalogs.Provider{
			ID:   "test",
			Name: "Test",
			Models: map[string]*catalogs.Model{
				model.ID: model,
			},
		}

		err = catalog.SetProvider(*provider)
		require.NoError(t, err)

		gen := &Generator{
			outputDir: tmpDir,
			verbose:   false,
		}

		modelFile := filepath.Join(modelsDir, model.ID+".md")
		authorMap := make(map[catalogs.AuthorID]*catalogs.Author)
		for _, author := range catalog.Authors().List() {
			authorMap[author.ID] = &author
		}
		err = gen.generateProviderModelPage(modelFile, model, provider, authorMap)
		assert.Error(t, err)
	})
}
