package docs

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/agentstation/starmap/pkg/catalogs"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateAuthorDocs(t *testing.T) {
	// Create temp directory
	tempDir := t.TempDir()

	// Create test catalog with authors and models
	catalog := createTestCatalogWithAuthors()

	// Create generator
	g := New(WithOutputDir(tempDir))

	// Generate author documentation
	err := g.generateAuthorDocs(filepath.Join(tempDir, "catalog", "authors"), catalog)
	require.NoError(t, err)

	// Check that directories were created
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "authors"))

	// Check that author directories exist
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "authors", "openai"))
	assert.DirExists(t, filepath.Join(tempDir, "catalog", "authors", "anthropic"))

	// Check that README files were created
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "authors", "README.md"))
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "authors", "openai", "README.md"))
	assert.FileExists(t, filepath.Join(tempDir, "catalog", "authors", "anthropic", "README.md"))
}

func TestGenerateAuthorIndex(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogWithAuthors()
	g := New()

	authors := catalog.Authors().List()
	allModels := catalog.GetAllModels()
	// Convert to pointer slice
	models := make([]*catalogs.Model, len(allModels))
	for i := range allModels {
		models[i] = &allModels[i]
	}

	err := g.generateAuthorIndex(tempDir, authors, models, catalog)
	require.NoError(t, err)

	// Read the generated index
	indexPath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(indexPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check for expected content
	assert.Contains(t, contentStr, "# üë• Model Authors")
	assert.Contains(t, contentStr, "## Author Overview")
	assert.Contains(t, contentStr, "| Author | Models | Hosted By | Focus Area |")

	// Check for author entries
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "Anthropic")

	// Check for categories
	assert.Contains(t, contentStr, "## By Category")
	assert.Contains(t, contentStr, "üè¢ Major Tech Companies")
	assert.Contains(t, contentStr, "üöÄ AI Startups")

	// Check footer - allow for potential newlines in markdown
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGenerateAuthorReadme(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogWithAuthors()
	g := New()

	// Get an author from the catalog
	author, found := catalog.Authors().Get(catalogs.AuthorIDOpenAI)
	require.True(t, found)

	// Generate the author README
	err := g.generateAuthorReadme(tempDir, author, catalog)
	require.NoError(t, err)

	// Read the generated README
	readmePath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(readmePath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check for expected sections
	assert.Contains(t, contentStr, "# <img src=")
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "## Organization Information")
	assert.Contains(t, contentStr, "| Field | Value |")
	assert.Contains(t, contentStr, "| **Author ID** | `openai` |")

	// Check for models section
	assert.Contains(t, contentStr, "## Models")
	assert.Contains(t, contentStr, "| Model | Providers | Context | Capabilities |")

	// Check for provider availability
	assert.Contains(t, contentStr, "## Provider Availability")

	// Check for navigation
	assert.Contains(t, contentStr, "### See Also")
	assert.Contains(t, contentStr, "[All Authors]")
	assert.Contains(t, contentStr, "[Browse by Provider]")

	// Check footer
	assert.Contains(t, contentStr, "Back to Authors")
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGenerateAuthorModelPages(t *testing.T) {
	tempDir := t.TempDir()
	modelsDir := filepath.Join(tempDir, "models")
	catalog := createTestCatalogWithAuthors()
	g := New()

	// Get an author
	author, found := catalog.Authors().Get(catalogs.AuthorIDOpenAI)
	require.True(t, found)

	// Generate model pages
	err := g.generateAuthorModelPages(modelsDir, author, catalog)
	require.NoError(t, err)

	// Check that models directory was created
	assert.DirExists(t, modelsDir)

	// Check that model files were created
	allModels := catalog.GetAllModels()
	// Convert to pointer slice
	models := make([]*catalogs.Model, len(allModels))
	for i := range allModels {
		models[i] = &allModels[i]
	}
	for _, model := range models {
		for _, ma := range model.Authors {
			if ma.ID == author.ID {
				// Model should have a file
				modelPath, err := getModelFilePath(modelsDir, model.ID)
				require.NoError(t, err)
				assert.FileExists(t, modelPath)
				break
			}
		}
	}
}

func TestGenerateAuthorModelPage(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogWithAuthors()
	g := New()

	// Get an author and model
	author, found := catalog.Authors().Get(catalogs.AuthorIDOpenAI)
	require.True(t, found)

	model, err := catalog.FindModel("gpt-4")
	require.NoError(t, err)

	// Generate the model page
	err = g.generateAuthorModelPage(tempDir, author, &model, catalog)
	require.NoError(t, err)

	// Check that the file was created
	modelPath, err := getModelFilePath(tempDir, model.ID)
	require.NoError(t, err)
	assert.FileExists(t, modelPath)

	// Read the generated content
	content, err := os.ReadFile(modelPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check for expected content
	assert.Contains(t, contentStr, "---")
	assert.Contains(t, contentStr, "title: \"GPT-4\"")
	assert.Contains(t, contentStr, "author: \"OpenAI\"")
	assert.Contains(t, contentStr, "type: model")

	// Check breadcrumb
	assert.Contains(t, contentStr, "[Catalog]")
	assert.Contains(t, contentStr, "[Authors]")
	assert.Contains(t, contentStr, "OpenAI")
	assert.Contains(t, contentStr, "**GPT-4**")

	// Check model details
	assert.Contains(t, contentStr, "# GPT-4")
	assert.Contains(t, contentStr, "## üìã Technical Specifications")
	assert.Contains(t, contentStr, "| Specification | Value |")

	// Check capabilities
	assert.Contains(t, contentStr, "## üéØ Capabilities")

	// Check providers section
	assert.Contains(t, contentStr, "## üåê Provider Availability")

	// Check related resources
	assert.Contains(t, contentStr, "### üîó Related Resources")

	// Check footer - allow for potential newlines in markdown
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGroupAuthorModels(t *testing.T) {
	models := []*catalogs.Model{
		{
			ID:   "gpt-4",
			Name: "GPT-4",
		},
		{
			ID:   "gpt-3.5-turbo",
			Name: "GPT-3.5 Turbo",
		},
		{
			ID:   "claude-3-opus",
			Name: "Claude 3 Opus",
		},
		{
			ID:   "claude-3-sonnet",
			Name: "Claude 3 Sonnet",
		},
		{
			ID:   "llama-3-70b",
			Name: "Llama 3 70B",
		},
		{
			ID:   "gemini-pro",
			Name: "Gemini Pro",
		},
	}

	result := groupAuthorModels(models)

	// Check that families were created
	assert.NotEmpty(t, result)

	// Check for expected families
	_, hasGPT := result["GPT"]
	assert.True(t, hasGPT)

	_, hasClaude := result["Claude"]
	assert.True(t, hasClaude)

	// Check model assignments
	assert.Len(t, result["GPT"], 2)
	assert.Len(t, result["Claude"], 2)
}

func TestCategorizeAuthor(t *testing.T) {
	tests := []struct {
		name     string
		author   *catalogs.Author
		expected string
	}{
		{
			name: "OpenAI",
			author: &catalogs.Author{
				ID:   catalogs.AuthorIDOpenAI,
				Name: "OpenAI",
			},
			expected: "üöÄ AI Startups",
		},
		{
			name: "Google",
			author: &catalogs.Author{
				ID:   catalogs.AuthorIDGoogle,
				Name: "Google",
			},
			expected: "üè¢ Major Tech Companies",
		},
		{
			name: "MIT",
			author: &catalogs.Author{
				ID:   catalogs.AuthorIDMIT,
				Name: "MIT",
			},
			expected: "üéì Research Organizations",
		},
		{
			name: "Unknown",
			author: &catalogs.Author{
				ID:   catalogs.AuthorID("unknown"),
				Name: "Unknown",
			},
			expected: "üåç Open Source",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := categorizeAuthor(tt.author)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetFocusArea(t *testing.T) {
	tests := []struct {
		name     string
		author   *catalogs.Author
		expected string
	}{
		{
			name: "OpenAI",
			author: &catalogs.Author{
				ID:   catalogs.AuthorIDOpenAI,
				Name: "OpenAI",
			},
			expected: "AGI Research",
		},
		{
			name: "Anthropic",
			author: &catalogs.Author{
				ID:   catalogs.AuthorIDAnthropic,
				Name: "Anthropic",
			},
			expected: "AI Safety",
		},
		{
			name: "Stability",
			author: &catalogs.Author{
				ID:   catalogs.AuthorIDStabilityAI,
				Name: "Stability AI",
			},
			expected: "Image Generation",
		},
		{
			name: "Unknown",
			author: &catalogs.Author{
				ID:   catalogs.AuthorID("unknown"),
				Name: "Unknown",
			},
			expected: "General AI",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getFocusArea(tt.author)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestShouldShowResearch(t *testing.T) {
	tests := []struct {
		name     string
		author   *catalogs.Author
		expected bool
	}{
		{
			name: "OpenAI - should show",
			author: &catalogs.Author{
				ID: catalogs.AuthorIDOpenAI,
			},
			expected: true,
		},
		{
			name: "Anthropic - should show",
			author: &catalogs.Author{
				ID: catalogs.AuthorIDAnthropic,
			},
			expected: true,
		},
		{
			name: "Random company - should not show",
			author: &catalogs.Author{
				ID: catalogs.AuthorID("randomcompany"),
			},
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := shouldShowResearch(tt.author)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetResearchInfo(t *testing.T) {
	tests := []struct {
		name     string
		author   *catalogs.Author
		expected string
	}{
		{
			name: "OpenAI",
			author: &catalogs.Author{
				ID: catalogs.AuthorIDOpenAI,
			},
			expected: "ai safety",
		},
		{
			name: "Google",
			author: &catalogs.Author{
				ID: catalogs.AuthorIDGoogle,
			},
			expected: "transformer architecture",
		},
		{
			name: "Unknown",
			author: &catalogs.Author{
				ID: catalogs.AuthorID("unknown"),
			},
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getResearchInfo(tt.author)
			// Just check if it contains expected text (partial match)
			if tt.expected != "" {
				assert.Contains(t, strings.ToLower(result), tt.expected)
			} else {
				assert.Empty(t, result)
			}
		})
	}
}

// Helper function to create test catalog with authors
func createTestCatalogWithAuthors() catalogs.Reader {
	catalog, _ := catalogs.New()

	// Add authors
	openai := catalogs.Author{
		ID:   catalogs.AuthorIDOpenAI,
		Name: "OpenAI",
	}
	anthropic := catalogs.Author{
		ID:   catalogs.AuthorIDAnthropic,
		Name: "Anthropic",
	}
	google := catalogs.Author{
		ID:   catalogs.AuthorIDGoogle,
		Name: "Google",
	}
	catalog.SetAuthor(openai)
	catalog.SetAuthor(anthropic)
	catalog.SetAuthor(google)

	// Add providers
	provider := catalogs.Provider{
		ID:     catalogs.ProviderIDOpenAI,
		Name:   "OpenAI",
		Models: make(map[string]catalogs.Model),
	}
	catalog.SetProvider(provider)

	// Add models with authors
	gpt4 := catalogs.Model{
		ID:   "gpt-4",
		Name: "GPT-4",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDOpenAI, Name: "OpenAI"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 8192,
		},
	}

	claude := catalogs.Model{
		ID:   "claude-3-opus",
		Name: "Claude 3 Opus",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDAnthropic, Name: "Anthropic"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText, catalogs.ModelModalityImage},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 200000,
		},
	}

	gemini := catalogs.Model{
		ID:   "gemini-pro",
		Name: "Gemini Pro",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDGoogle, Name: "Google"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 32768,
		},
	}

	// Associate models with provider
	provider.Models = map[string]catalogs.Model{
		gpt4.ID:   gpt4,
		claude.ID: claude,
		gemini.ID: gemini,
	}
	catalog.SetProvider(provider)

	return catalog
}

// TestGenerateAuthorDocsComprehensive tests the generateAuthorDocs function
func TestGenerateAuthorDocsComprehensive(t *testing.T) {
	tests := []struct {
		name      string
		authors   []catalogs.Author
		models    []catalogs.Model
		wantErr   bool
		checkFunc func(t *testing.T, outputDir string)
	}{
		{
			name:    "empty author list",
			authors: []catalogs.Author{},
			models:  []catalogs.Model{},
			checkFunc: func(t *testing.T, outputDir string) {
				// Index should still be created
				indexPath := filepath.Join(outputDir, "README.md")
				assert.FileExists(t, indexPath)

				content, err := os.ReadFile(indexPath)
				require.NoError(t, err)
				assert.Contains(t, string(content), "Model Authors")
			},
		},
		{
			name: "authors with no models",
			authors: []catalogs.Author{
				{ID: "openai", Name: "OpenAI"},
				{ID: "anthropic", Name: "Anthropic"},
			},
			models: []catalogs.Model{},
			checkFunc: func(t *testing.T, outputDir string) {
				// Check directories created
				assert.DirExists(t, filepath.Join(outputDir, "openai"))
				assert.DirExists(t, filepath.Join(outputDir, "anthropic"))

				// Check READMEs exist
				assert.FileExists(t, filepath.Join(outputDir, "openai", "README.md"))
				assert.FileExists(t, filepath.Join(outputDir, "anthropic", "README.md"))

				// Check index
				indexPath := filepath.Join(outputDir, "README.md")
				content, err := os.ReadFile(indexPath)
				require.NoError(t, err)
				assert.Contains(t, string(content), "OpenAI")
				assert.Contains(t, string(content), "Anthropic")
			},
		},
		{
			name: "authors with description",
			authors: []catalogs.Author{
				{
					ID:          "researcher",
					Name:        "Research Team",
					Description: stringPtr("Leading AI research organization focused on open models"),
				},
			},
			models: []catalogs.Model{},
			checkFunc: func(t *testing.T, outputDir string) {
				readmePath := filepath.Join(outputDir, "researcher", "README.md")
				assert.FileExists(t, readmePath)

				content, err := os.ReadFile(readmePath)
				require.NoError(t, err)
				contentStr := string(content)
				assert.Contains(t, contentStr, "Research Team")
				assert.Contains(t, contentStr, "Leading AI research")
			},
		},
		{
			name: "authors with models",
			authors: []catalogs.Author{
				{ID: "openai", Name: "OpenAI"},
				{ID: "meta", Name: "Meta"},
			},
			models: []catalogs.Model{
				{
					ID:   "gpt-4",
					Name: "GPT-4",
					Authors: []catalogs.Author{
						{ID: "openai", Name: "OpenAI"},
					},
				},
				{
					ID:   "llama-3",
					Name: "Llama 3",
					Authors: []catalogs.Author{
						{ID: "meta", Name: "Meta"},
					},
				},
				{
					ID:   "collaborative-model",
					Name: "Collaborative Model",
					Authors: []catalogs.Author{
						{ID: "openai", Name: "OpenAI"},
						{ID: "meta", Name: "Meta"},
					},
				},
			},
			checkFunc: func(t *testing.T, outputDir string) {
				// Check OpenAI has 2 models (gpt-4 and collaborative)
				openaiReadme := filepath.Join(outputDir, "openai", "README.md")
				content, err := os.ReadFile(openaiReadme)
				require.NoError(t, err)
				contentStr := string(content)
				assert.Contains(t, contentStr, "GPT-4")
				assert.Contains(t, contentStr, "Collaborative Model")

				// Check Meta has 2 models (llama-3 and collaborative)
				metaReadme := filepath.Join(outputDir, "meta", "README.md")
				content, err = os.ReadFile(metaReadme)
				require.NoError(t, err)
				contentStr = string(content)
				assert.Contains(t, contentStr, "Llama 3")
				assert.Contains(t, contentStr, "Collaborative Model")
			},
		},
		{
			name:    "large number of authors",
			authors: generateManyAuthors(25),
			models:  []catalogs.Model{},
			checkFunc: func(t *testing.T, outputDir string) {
				// Check all directories created
				for i := 0; i < 25; i++ {
					authorDir := filepath.Join(outputDir, stringID("author", i))
					assert.DirExists(t, authorDir)
				}

				// Check index contains all authors
				indexPath := filepath.Join(outputDir, "README.md")
				content, err := os.ReadFile(indexPath)
				require.NoError(t, err)
				contentStr := string(content)
				// Check that all 25 authors are listed
				assert.Contains(t, contentStr, "Author 0")
				assert.Contains(t, contentStr, "author-0")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			authorsDir := filepath.Join(tmpDir, "authors")

			// Create catalog
			catalog, err := catalogs.New()
			require.NoError(t, err)

			// Add authors
			for _, author := range tt.authors {
				err := catalog.SetAuthor(author)
				require.NoError(t, err)
			}

			// Create a test provider to hold all models
			provider := catalogs.Provider{
				ID:     catalogs.ProviderID("test-provider"),
				Name:   "Test Provider",
				Models: make(map[string]catalogs.Model),
			}

			// Add all models to the provider
			for _, model := range tt.models {
				provider.Models[model.ID] = model
			}

			// Set the provider with all models
			err = catalog.SetProvider(provider)
			require.NoError(t, err)

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate author docs
			err = gen.generateAuthorDocs(authorsDir, catalog)
			require.NoError(t, err)

			if tt.checkFunc != nil {
				tt.checkFunc(t, authorsDir)
			}
		})
	}
}

// TestGenerateAuthorDocsErrors tests error handling in generateAuthorDocs
func TestGenerateAuthorDocsErrors(t *testing.T) {
	t.Run("directory creation failure", func(t *testing.T) {
		tmpDir := t.TempDir()

		// Create a file where directory should be
		authorsDir := filepath.Join(tmpDir, "authors")
		err := os.WriteFile(authorsDir, []byte("file"), 0644)
		require.NoError(t, err)

		catalog, err := catalogs.New()
		require.NoError(t, err)

		// Add an author
		err = catalog.SetAuthor(catalogs.Author{
			ID:   "test",
			Name: "Test Author",
		})
		require.NoError(t, err)

		gen := &Generator{
			outputDir: tmpDir,
			verbose:   false,
		}

		err = gen.generateAuthorDocs(authorsDir, catalog)
		assert.Error(t, err)
	})

	t.Run("index write failure", func(t *testing.T) {
		tmpDir := t.TempDir()
		authorsDir := filepath.Join(tmpDir, "authors")
		err := os.MkdirAll(authorsDir, 0755)
		require.NoError(t, err)

		// Make directory read-only
		err = os.Chmod(authorsDir, 0555)
		require.NoError(t, err)
		defer os.Chmod(authorsDir, 0755)

		catalog, err := catalogs.New()
		require.NoError(t, err)

		gen := &Generator{
			outputDir: tmpDir,
			verbose:   false,
		}

		err = gen.generateAuthorDocs(authorsDir, catalog)
		assert.Error(t, err)
	})
}

// TestGenerateAuthorModelPageComplex tests generateAuthorModelPage with complex scenarios
func TestGenerateAuthorModelPageComplex(t *testing.T) {
	tests := []struct {
		name     string
		author   *catalogs.Author
		model    *catalogs.Model
		contains []string
	}{
		{
			name: "cross-provider model",
			author: &catalogs.Author{
				ID:   "openai",
				Name: "OpenAI",
			},
			model: &catalogs.Model{
				ID:   "gpt-4",
				Name: "GPT-4",
				Authors: []catalogs.Author{
					{ID: "openai", Name: "OpenAI"},
				},
				Description: "Advanced language model with broad capabilities",
			},
			contains: []string{
				"# GPT-4",
				"OpenAI",
				"Advanced language model",
			},
		},
		{
			name: "research model with metadata",
			author: &catalogs.Author{
				ID:      "research-lab",
				Name:    "Research Lab",
				Website: stringPtr("https://research-lab.org"),
			},
			model: &catalogs.Model{
				ID:   "research-model",
				Name: "Research Model v2",
				Authors: []catalogs.Author{
					{ID: "research-lab", Name: "Research Lab"},
				},
				Description: "State-of-the-art research model published by Research Lab",
				Metadata: &catalogs.ModelMetadata{
					OpenWeights: true,
					Tags: []catalogs.ModelTag{
						catalogs.ModelTagResearch,
						catalogs.ModelTagCreative,
					},
				},
			},
			contains: []string{
				"Research Model v2",
				"Research Lab",
			},
		},
		{
			name: "model with organization",
			author: &catalogs.Author{
				ID:          "sub-team",
				Name:        "AI Sub Team",
				Description: stringPtr("AI research division of a larger organization"),
			},
			model: &catalogs.Model{
				ID:   "team-model",
				Name: "Team Model",
				Authors: []catalogs.Author{
					{ID: "sub-team", Name: "AI Sub Team"},
				},
			},
			contains: []string{
				"Team Model",
				"AI Sub Team",
			},
		},
		{
			name: "model with special metadata",
			author: &catalogs.Author{
				ID:   "innovative-co",
				Name: "Innovative Company",
			},
			model: &catalogs.Model{
				ID:   "special-model",
				Name: "Special Model",
				Authors: []catalogs.Author{
					{ID: "innovative-co", Name: "Innovative Company"},
				},
				Description: "A special model with unique capabilities",
				Features: &catalogs.ModelFeatures{
					Tools:     true,
					ToolCalls: true,
					Modalities: catalogs.ModelModalities{
						Input: []catalogs.ModelModality{
							catalogs.ModelModalityText,
							catalogs.ModelModalityImage,
						},
						Output: []catalogs.ModelModality{
							catalogs.ModelModalityText,
						},
					},
				},
			},
			contains: []string{
				"Special Model",
				"Innovative Company",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			modelsDir := filepath.Join(tmpDir, "models")
			err := os.MkdirAll(modelsDir, 0755)
			require.NoError(t, err)

			// Create catalog
			catalog, err := catalogs.New()
			require.NoError(t, err)

			// Add author
			err = catalog.SetAuthor(*tt.author)
			require.NoError(t, err)

			// Add model
			// Add model to provider
			provider, _ := catalog.Provider(catalogs.ProviderID("openai"))
			if provider.Models == nil {
				provider.Models = make(map[string]catalogs.Model)
			}
			provider.Models[tt.model.ID] = *tt.model
			err = catalog.SetProvider(provider)
			require.NoError(t, err)

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate author model page
			err = gen.generateAuthorModelPage(modelsDir, tt.author, tt.model, catalog)
			require.NoError(t, err)

			// Check file exists and contains expected content
			modelPath := filepath.Join(modelsDir, tt.model.ID+".md")
			assert.FileExists(t, modelPath)

			content, err := os.ReadFile(modelPath)
			require.NoError(t, err)
			contentStr := string(content)

			for _, expected := range tt.contains {
				assert.Contains(t, contentStr, expected, "Should contain: %s", expected)
			}
		})
	}
}

// TestGenerateAuthorReadmeEdgeCases tests edge cases for generateAuthorReadme
func TestGenerateAuthorReadmeEdgeCases(t *testing.T) {
	tests := []struct {
		name     string
		author   *catalogs.Author
		models   []catalogs.Model
		contains []string
	}{
		{
			name: "author with no models",
			author: &catalogs.Author{
				ID:   "empty-author",
				Name: "Empty Author",
			},
			models: []catalogs.Model{},
			contains: []string{
				"Empty Author",
				"No models found from this author",
			},
		},
		{
			name: "author with website and social links",
			author: &catalogs.Author{
				ID:      "social-author",
				Name:    "Social Author",
				Website: stringPtr("https://example.com"),
				Twitter: stringPtr("@social_author"),
				GitHub:  stringPtr("social-author"),
			},
			models: []catalogs.Model{},
			contains: []string{
				"Social Author",
				"https://example.com",
			},
		},
		{
			name: "author with huggingface and github",
			author: &catalogs.Author{
				ID:          "established-org",
				Name:        "Established Organization",
				Description: stringPtr("A well-established AI organization"),
				HuggingFace: stringPtr("https://huggingface.co/established-org"),
				GitHub:      stringPtr("established-org"),
			},
			models: []catalogs.Model{},
			contains: []string{
				"Established Organization",
				"well-established",
			},
		},
		{
			name: "author with 50+ models",
			author: &catalogs.Author{
				ID:   "prolific-author",
				Name: "Prolific Author",
			},
			models: generateManyModelsForAuthor("prolific-author", 50),
			contains: []string{
				"Prolific Author",
				"Total Models",
				"Model 0", // Actual output uses "Model" not "Authored Model"
				"Model C", // 49th model will be Model C based on hex pattern
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tmpDir := t.TempDir()
			authorDir := filepath.Join(tmpDir, string(tt.author.ID))
			err := os.MkdirAll(authorDir, 0755)
			require.NoError(t, err)

			// Create catalog
			catalog, err := catalogs.New()
			require.NoError(t, err)

			// Add author
			err = catalog.SetAuthor(*tt.author)
			require.NoError(t, err)

			// Create a test provider to hold all models
			provider := catalogs.Provider{
				ID:     catalogs.ProviderID("test-provider"),
				Name:   "Test Provider",
				Models: make(map[string]catalogs.Model),
			}

			// Add all models to the provider
			for _, model := range tt.models {
				provider.Models[model.ID] = model
			}

			// Set the provider with all models
			err = catalog.SetProvider(provider)
			require.NoError(t, err)

			// Create generator
			gen := &Generator{
				outputDir: tmpDir,
				verbose:   false,
			}

			// Generate author readme
			err = gen.generateAuthorReadme(authorDir, tt.author, catalog)
			require.NoError(t, err)

			// Check README exists
			readmePath := filepath.Join(authorDir, "README.md")
			assert.FileExists(t, readmePath)

			// Check content
			content, err := os.ReadFile(readmePath)
			require.NoError(t, err)
			contentStr := string(content)

			for _, expected := range tt.contains {
				assert.Contains(t, contentStr, expected, "Should contain: %s", expected)
			}
		})
	}
}

// Helper functions for author tests
func stringPtr(s string) *string {
	return &s
}

func stringID(prefix string, index int) string {
	return fmt.Sprintf("%s-%d", prefix, index)
}

func stringName(prefix string, index int) string {
	return fmt.Sprintf("%s %d", prefix, index)
}

func generateManyAuthors(count int) []catalogs.Author {
	authors := make([]catalogs.Author, count)
	for i := 0; i < count; i++ {
		authors[i] = catalogs.Author{
			ID:   catalogs.AuthorID(stringID("author", i)),
			Name: stringName("Author", i),
		}
	}
	return authors
}

func generateManyModelsForAuthor(authorID string, count int) []catalogs.Model {
	models := make([]catalogs.Model, count)
	for i := 0; i < count; i++ {
		models[i] = catalogs.Model{
			ID:   stringID("model", i),
			Name: stringName("Model", i),
			Authors: []catalogs.Author{
				{ID: catalogs.AuthorID(authorID), Name: "Author"},
			},
		}
	}
	return models
}
