package docs

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/agentstation/starmap/pkg/catalogs"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGenerateCatalogIndex(t *testing.T) {
	tempDir := t.TempDir()
	catalog := createTestCatalogComplete()
	g := New()

	err := g.generateCatalogIndex(tempDir, catalog)
	require.NoError(t, err)

	// Read the generated index
	indexPath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(indexPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Check header and description
	assert.Contains(t, contentStr, "# üåü Starmap AI Model Catalog")
	assert.Contains(t, contentStr, "A comprehensive catalog of AI models")

	// Check last updated (should be today's date)
	today := time.Now().Format("January 2, 2006")
	assert.Contains(t, contentStr, "_Last Updated: "+today)

	// Check statistics section
	assert.Contains(t, contentStr, "## üìä Catalog Statistics")
	assert.Contains(t, contentStr, "| **Total Models** |")
	assert.Contains(t, contentStr, "| **Providers** |")
	assert.Contains(t, contentStr, "| **Model Authors** |")
	assert.Contains(t, contentStr, "| **Models with Pricing** |")
	assert.Contains(t, contentStr, "| **Average Context** |")

	// Check navigation section
	assert.Contains(t, contentStr, "## üöÄ Quick Navigation")
	assert.Contains(t, contentStr, "### Browse by Provider")
	assert.Contains(t, contentStr, "| Provider | Models | Latest Addition |")

	// Check provider links
	assert.Contains(t, contentStr, "[OpenAI](providers/openai/)")
	assert.Contains(t, contentStr, "[Anthropic](providers/anthropic/)")

	// Check author section
	assert.Contains(t, contentStr, "### Browse by Model Author")
	assert.Contains(t, contentStr, "| Author | Models | Description |")

	// Check featured models
	assert.Contains(t, contentStr, "## ‚≠ê Featured Models")
	assert.Contains(t, contentStr, "### Latest & Greatest")

	// Check browse options
	assert.Contains(t, contentStr, "## üìö Browse Options")
	assert.Contains(t, contentStr, "**[By Provider](providers/)**")
	assert.Contains(t, contentStr, "**[By Author](authors/)**")
	assert.Contains(t, contentStr, "**[All Models](models/)**")

	// Check footer
	assert.Contains(t, contentStr, "Generated by")
	assert.Contains(t, contentStr, "[Starmap](https://github.com/agentstation/starmap)")
}

func TestGenerateCatalogIndexEmptyCatalog(t *testing.T) {
	tempDir := t.TempDir()
	catalog, _ := catalogs.New() // Empty catalog
	g := New()

	err := g.generateCatalogIndex(tempDir, catalog)
	require.NoError(t, err)

	// Read the generated index
	indexPath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(indexPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Should still generate valid structure with zero values
	assert.Contains(t, contentStr, "| **Total Models** | 0 |")
	assert.Contains(t, contentStr, "| **Providers** | 0 |")
	assert.Contains(t, contentStr, "| **Model Authors** | 0 |")
}

func TestGenerateCatalogIndexWithManyAuthors(t *testing.T) {
	tempDir := t.TempDir()
	catalog, _ := catalogs.New()

	// Add more than 10 authors
	for i := 0; i < 15; i++ {
		author := catalogs.Author{
			ID:   catalogs.AuthorID(fmt.Sprintf("author-%d", i)),
			Name: fmt.Sprintf("Author %d", i),
		}
		catalog.SetAuthor(author)

		// Add a model for each author to ensure they show up
		model := catalogs.Model{
			ID:   fmt.Sprintf("model-%d", i),
			Name: fmt.Sprintf("Model %d", i),
			Authors: []catalogs.Author{
				{ID: author.ID, Name: author.Name},
			},
		}
		catalog.SetModel(model)
	}

	g := New()
	err := g.generateCatalogIndex(tempDir, catalog)
	require.NoError(t, err)

	// Read the generated index
	indexPath := filepath.Join(tempDir, "README.md")
	content, err := os.ReadFile(indexPath)
	require.NoError(t, err)

	contentStr := string(content)

	// Should show link to view all authors
	assert.Contains(t, contentStr, "[View all 15 authors ‚Üí](authors/)")
}

func TestSelectFeaturedModels(t *testing.T) {
	models := []*catalogs.Model{
		{
			ID:   "gpt-4",
			Name: "GPT-4",
			Pricing: &catalogs.ModelPricing{
				Tokens: &catalogs.TokenPricing{
					Input: &catalogs.TokenCost{Per1M: 30.0},
				},
			},
		},
		{
			ID:   "claude-3-opus",
			Name: "Claude 3 Opus",
			Pricing: &catalogs.ModelPricing{
				Tokens: &catalogs.TokenPricing{
					Input: &catalogs.TokenCost{Per1M: 15.0},
				},
			},
		},
		{
			ID:   "no-pricing",
			Name: "No Pricing Model",
		},
		{
			ID:   "gemini-pro",
			Name: "Gemini Pro",
			Pricing: &catalogs.ModelPricing{
				Tokens: &catalogs.TokenPricing{
					Input: &catalogs.TokenCost{Per1M: 0.5},
				},
			},
		},
	}

	featured := selectFeaturedModels(models)

	// Should only include models with pricing
	assert.Len(t, featured, 3)

	// Should be sorted by priority
	assert.Equal(t, "GPT-4", featured[0].Name)
	assert.Equal(t, "Claude 3 Opus", featured[1].Name)
	assert.Equal(t, "Gemini Pro", featured[2].Name)
}

func TestGetModelPriority(t *testing.T) {
	tests := []struct {
		name     string
		model    string
		expected int
	}{
		{
			name:     "GPT-4 highest priority",
			model:    "GPT-4",
			expected: 1,
		},
		{
			name:     "GPT-4 variant",
			model:    "GPT-4-turbo",
			expected: 1,
		},
		{
			name:     "Claude second priority",
			model:    "Claude 3 Opus",
			expected: 2,
		},
		{
			name:     "Gemini third priority",
			model:    "Gemini Pro",
			expected: 3,
		},
		{
			name:     "Llama fourth priority",
			model:    "Llama 3 70B",
			expected: 4,
		},
		{
			name:     "Mixtral fifth priority",
			model:    "Mixtral 8x7B",
			expected: 5,
		},
		{
			name:     "DeepSeek sixth priority",
			model:    "DeepSeek V2",
			expected: 6,
		},
		{
			name:     "Unknown model lowest priority",
			model:    "Random Model",
			expected: 999,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getModelPriority(tt.model)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetProviderBadge(t *testing.T) {
	tests := []struct {
		name     string
		provider string
		expected string
	}{
		{
			name:     "OpenAI",
			provider: "OpenAI",
			expected: "ü§ñ",
		},
		{
			name:     "Anthropic",
			provider: "Anthropic",
			expected: "üß†", // Matches actual implementation
		},
		{
			name:     "Google",
			provider: "Google",
			expected: "üè¢", // No specific entry for Google, uses default
		},
		{
			name:     "Unknown provider",
			provider: "Unknown",
			expected: "üè¢", // Default badge
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getProviderBadge(tt.provider)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGetAuthorBadge(t *testing.T) {
	tests := []struct {
		name     string
		author   string
		expected string
	}{
		{
			name:     "OpenAI",
			author:   "OpenAI",
			expected: "ü§ñ", // Matches actual implementation
		},
		{
			name:     "Meta",
			author:   "Meta",
			expected: "üìò",
		},
		{
			name:     "Google",
			author:   "Google",
			expected: "üîç",
		},
		{
			name:     "Unknown author",
			author:   "Unknown",
			expected: "üë•", // Default badge for authors
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := getAuthorBadge(tt.author)
			assert.Equal(t, tt.expected, result)
		})
	}
}

// TestFormatNumber is already defined in utils_test.go

// TestMin is already defined in utils_test.go

// Helper function to create a complete test catalog
func createTestCatalogComplete() catalogs.Reader {
	catalog, _ := catalogs.New()

	// Add authors
	openai := catalogs.Author{
		ID:   catalogs.AuthorIDOpenAI,
		Name: "OpenAI",
	}
	desc := "AI research company"
	openai.Description = &desc

	anthropic := catalogs.Author{
		ID:   catalogs.AuthorIDAnthropic,
		Name: "Anthropic",
	}
	desc2 := "AI safety company"
	anthropic.Description = &desc2

	catalog.SetAuthor(openai)
	catalog.SetAuthor(anthropic)

	// Add providers
	openaiProvider := catalogs.Provider{
		ID:     catalogs.ProviderIDOpenAI,
		Name:   "OpenAI",
		Models: make(map[string]catalogs.Model),
	}

	anthropicProvider := catalogs.Provider{
		ID:     catalogs.ProviderIDAnthropic,
		Name:   "Anthropic",
		Models: make(map[string]catalogs.Model),
	}

	// Add models
	gpt4 := catalogs.Model{
		ID:   "gpt-4",
		Name: "GPT-4",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDOpenAI, Name: "OpenAI"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 8192,
		},
		Pricing: &catalogs.ModelPricing{
			Tokens: &catalogs.TokenPricing{
				Input:  &catalogs.TokenCost{Per1M: 30.0},
				Output: &catalogs.TokenCost{Per1M: 60.0},
			},
		},
	}

	claude := catalogs.Model{
		ID:   "claude-3-opus",
		Name: "Claude 3 Opus",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDAnthropic, Name: "Anthropic"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityText, catalogs.ModelModalityImage},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
		},
		Limits: &catalogs.ModelLimits{
			ContextWindow: 200000,
		},
		Pricing: &catalogs.ModelPricing{
			Tokens: &catalogs.TokenPricing{
				Input:  &catalogs.TokenCost{Per1M: 15.0},
				Output: &catalogs.TokenCost{Per1M: 75.0},
			},
		},
	}

	// Add model without pricing
	whisper := catalogs.Model{
		ID:   "whisper-1",
		Name: "Whisper",
		Authors: []catalogs.Author{
			{ID: catalogs.AuthorIDOpenAI, Name: "OpenAI"},
		},
		Features: &catalogs.ModelFeatures{
			Modalities: catalogs.ModelModalities{
				Input:  []catalogs.ModelModality{catalogs.ModelModalityAudio},
				Output: []catalogs.ModelModality{catalogs.ModelModalityText},
			},
		},
	}

	catalog.SetModel(gpt4)
	catalog.SetModel(claude)
	catalog.SetModel(whisper)

	// Associate models with providers
	openaiProvider.Models["gpt-4"] = gpt4
	openaiProvider.Models["whisper-1"] = whisper
	anthropicProvider.Models["claude-3-opus"] = claude

	catalog.SetProvider(openaiProvider)
	catalog.SetProvider(anthropicProvider)

	return catalog
}
