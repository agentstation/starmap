package docs

import (
	"fmt"
	"io"
	"path/filepath"
	"strings"
	"time"
)

// Breadcrumb represents a single breadcrumb navigation item
type Breadcrumb struct {
	Label string
	Path  string
}

// NavigationLink represents a navigation link with optional description
type NavigationLink struct {
	Label       string
	Path        string
	Description string
}

// NavigationContext provides context for generating navigation elements
type NavigationContext struct {
	Depth       int    // How many levels deep from root
	CurrentPath string // Current page path
	PageType    string // Type of page: "provider", "author", "model", "catalog"
}

// buildBreadcrumbs creates a breadcrumb navigation string
func (g *Generator) buildBreadcrumbs(items ...Breadcrumb) string {
	if len(items) == 0 {
		return ""
	}
	
	parts := []string{}
	
	for i, item := range items {
		if i == len(items)-1 {
			// Last item is current page (bold, no link)
			parts = append(parts, "**"+item.Label+"**")
		} else {
			// Build link manually to avoid newlines
			parts = append(parts, fmt.Sprintf("[%s](%s)", item.Label, item.Path))
		}
	}
	
	return strings.Join(parts, " / ")
}

// writeBreadcrumbs writes breadcrumb navigation to a writer
func (g *Generator) writeBreadcrumbs(w io.Writer, items ...Breadcrumb) {
	breadcrumbs := g.buildBreadcrumbs(items...)
	if breadcrumbs != "" {
		fmt.Fprintf(w, "%s\n\n", breadcrumbs)
	}
}

// buildFooter creates a standard footer with back links
func (g *Generator) buildFooter(backLinks ...Breadcrumb) string {
	parts := []string{}
	for _, link := range backLinks {
		// Build link manually to avoid newlines
		parts = append(parts, fmt.Sprintf("[‚Üê %s](%s)", link.Label, link.Path))
	}
	
	// Always add the Starmap credit
	parts = append(parts, "Generated by [Starmap](https://github.com/agentstation/starmap)")
	
	// Join all parts and wrap in italics
	footer := "_" + strings.Join(parts, " | ") + "_"
	
	return footer
}

// writeFooter writes a standard footer to a writer
func (g *Generator) writeFooter(w io.Writer, backLinks ...Breadcrumb) {
	fmt.Fprintf(w, "---\n%s\n", g.buildFooter(backLinks...))
}

// writeTimestampedFooter writes a footer with timestamp
func (g *Generator) writeTimestampedFooter(w io.Writer, backLinks ...Breadcrumb) {
	footerContent := g.buildFooter(backLinks...)
	// Remove outer underscores from the footer content for timestamp version
	if strings.HasPrefix(footerContent, "_") && strings.HasSuffix(footerContent, "_") {
		footerContent = footerContent[1 : len(footerContent)-1]
	}
	
	timestampedContent := fmt.Sprintf("Last Updated: %s | %s",
		time.Now().UTC().Format("2006-01-02 15:04:05 UTC"),
		footerContent)
	
	fmt.Fprintf(w, "---\n_%s_\n", timestampedContent)
}

// buildNavigationSection creates a navigation section with links
func (g *Generator) buildNavigationSection(title string, links []NavigationLink) string {
	if len(links) == 0 {
		return ""
	}
	
	var result strings.Builder
	result.WriteString(fmt.Sprintf("### %s\n\n", title))
	
	for _, link := range links {
		// Build link manually to avoid newlines
		item := fmt.Sprintf("- [%s](%s)", link.Label, link.Path)
		
		if link.Description != "" {
			item += " - " + link.Description
		}
		
		result.WriteString(item + "\n")
	}
	
	return result.String()
}

// writeNavigationSection writes a navigation section to a writer
func (g *Generator) writeNavigationSection(w io.Writer, title string, links []NavigationLink) {
	section := g.buildNavigationSection(title, links)
	if section != "" {
		fmt.Fprintf(w, "%s\n", section)
	}
}

// Path calculation helpers

// getRelativePath calculates the relative path from one location to another
func getRelativePath(from, to string) string {
	rel, err := filepath.Rel(from, to)
	if err != nil {
		return to // Fallback to absolute path
	}
	// Convert to forward slashes for markdown
	return strings.ReplaceAll(rel, string(filepath.Separator), "/")
}

// getCatalogPath returns the path to the catalog root from a given depth
func getCatalogPath(depth int) string {
	if depth <= 0 {
		return "."
	}
	parts := make([]string, depth)
	for i := range parts {
		parts[i] = ".."
	}
	return strings.Join(parts, "/")
}

// getProvidersPath returns the path to the providers directory from a given depth
func getProvidersPath(depth int) string {
	catalogPath := getCatalogPath(depth)
	if catalogPath == "." {
		return "providers"
	}
	return catalogPath + "/providers"
}

// getAuthorsPath returns the path to the authors directory from a given depth
func getAuthorsPath(depth int) string {
	catalogPath := getCatalogPath(depth)
	if catalogPath == "." {
		return "authors"
	}
	return catalogPath + "/authors"
}

// getModelsPath returns the path to the models directory from a given depth
func getModelsPath(depth int) string {
	catalogPath := getCatalogPath(depth)
	if catalogPath == "." {
		return "models"
	}
	return catalogPath + "/models"
}

// Standard breadcrumb generators

// providerBreadcrumb creates breadcrumbs for a provider page
func (g *Generator) providerBreadcrumb(providerName string) []Breadcrumb {
	return []Breadcrumb{
		{Label: "Catalog", Path: "../../"},
		{Label: "Providers", Path: "../"},
		{Label: providerName, Path: ""},
	}
}

// providerModelBreadcrumb creates breadcrumbs for a model under a provider
func (g *Generator) providerModelBreadcrumb(providerName, modelName string, modelID string) []Breadcrumb {
	// Calculate depth based on model ID (for subdirectories)
	// Base depth: catalog/providers/provider/models/model.md = 4 levels from catalog
	depth := 4 // catalog=0, providers=1, provider=2, models=3, model=4
	if strings.Contains(modelID, "/") {
		// Add one level for each subdirectory in the model ID
		// e.g., "openai/gpt-oss-120b" adds 1 level
		depth += strings.Count(modelID, "/")
	}
	
	catalogPath := getCatalogPath(depth)
	providersPath := getCatalogPath(depth-1)
	providerPath := getCatalogPath(depth-2)
	
	return []Breadcrumb{
		{Label: "Catalog", Path: catalogPath},
		{Label: "Providers", Path: providersPath},
		{Label: providerName, Path: providerPath},
		{Label: modelName, Path: ""},
	}
}

// authorBreadcrumb creates breadcrumbs for an author page
func (g *Generator) authorBreadcrumb(authorName string) []Breadcrumb {
	return []Breadcrumb{
		{Label: "Catalog", Path: "../../"},
		{Label: "Authors", Path: "../"},
		{Label: authorName, Path: ""},
	}
}

// authorModelBreadcrumb creates breadcrumbs for a model under an author
func (g *Generator) authorModelBreadcrumb(authorName, modelName string, modelID string) []Breadcrumb {
	// Calculate depth based on model ID (for subdirectories)
	// Base depth: catalog/authors/author/models/model.md = 4 levels from catalog
	depth := 4 // catalog=0, authors=1, author=2, models=3, model=4
	if strings.Contains(modelID, "/") {
		// Add one level for each subdirectory in the model ID
		// e.g., "openai/gpt-oss-120b" adds 1 level
		depth += strings.Count(modelID, "/")
	}
	
	catalogPath := getCatalogPath(depth)
	authorsPath := getCatalogPath(depth-1)
	authorPath := getCatalogPath(depth-2)
	
	return []Breadcrumb{
		{Label: "Catalog", Path: catalogPath},
		{Label: "Authors", Path: authorsPath},
		{Label: authorName, Path: authorPath},
		{Label: modelName, Path: ""},
	}
}

// Standard footer generators

// catalogFooter creates a footer for the main catalog page
func (g *Generator) catalogFooter() string {
	return g.buildFooter()
}

// providerIndexFooter creates a footer for the providers index
func (g *Generator) providerIndexFooter() string {
	return g.buildFooter(
		Breadcrumb{Label: "Back to Catalog", Path: "../"},
	)
}

// providerFooter creates a footer for a provider page
func (g *Generator) providerFooter() string {
	return g.buildFooter(
		Breadcrumb{Label: "Back to Providers", Path: "../"},
		Breadcrumb{Label: "Back to Catalog", Path: "../../"},
	)
}

// authorIndexFooter creates a footer for the authors index
func (g *Generator) authorIndexFooter() string {
	return g.buildFooter(
		Breadcrumb{Label: "Back to Catalog", Path: "../"},
	)
}

// authorFooter creates a footer for an author page
func (g *Generator) authorFooter() string {
	return g.buildFooter(
		Breadcrumb{Label: "Back to Authors", Path: "../"},
		Breadcrumb{Label: "Back to Catalog", Path: "../../"},
	)
}

// modelIndexFooter creates a footer for the models index
func (g *Generator) modelIndexFooter() string {
	return g.buildFooter(
		Breadcrumb{Label: "Back to Catalog", Path: "../"},
	)
}

// Cross-reference helpers

// buildProviderCrossReferences builds cross-reference links for a provider page
func (g *Generator) buildProviderCrossReferences(providerID string) []NavigationLink {
	return []NavigationLink{
		{Label: "All Providers", Path: "../"},
		{Label: "Browse by Author", Path: "../../authors/"},
		{Label: "Model Comparison", Path: "../../models/"},
	}
}

// buildAuthorCrossReferences builds cross-reference links for an author page
func (g *Generator) buildAuthorCrossReferences(authorID string) []NavigationLink {
	return []NavigationLink{
		{Label: "All Authors", Path: "../"},
		{Label: "Browse by Provider", Path: "../../providers/"},
		{Label: "Model Comparison", Path: "../../models/"},
	}
}

// buildModelCrossReferences builds cross-reference links for a model page
func (g *Generator) buildModelCrossReferences(context string, depth int) []NavigationLink {
	links := []NavigationLink{}
	
	// Add links to all providers and all authors
	links = append(links, NavigationLink{
		Label: "All Providers",
		Path:  getProvidersPath(depth),
	})
	
	links = append(links, NavigationLink{
		Label: "Back to Catalog",
		Path:  getCatalogPath(depth),
	})
	
	return links
}