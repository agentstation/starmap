package docs

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"github.com/agentstation/starmap/pkg/catalogs"
)

// generateModelDocs generates documentation for all models
func (g *Generator) generateModelDocs(dir string, catalog catalogs.Reader) error {
	models := catalog.Models().List()
	providers := catalog.Providers().List()
	authors := catalog.Authors().List()

	// Create provider and author maps for quick lookup
	providerMap := make(map[catalogs.ProviderID]*catalogs.Provider)
	for _, p := range providers {
		providerMap[p.ID] = p
	}

	authorMap := make(map[catalogs.AuthorID]*catalogs.Author)
	for _, a := range authors {
		authorMap[a.ID] = a
	}

	// First generate the model index
	if err := g.generateModelIndex(dir, models); err != nil {
		return fmt.Errorf("generating model index: %w", err)
	}

	// Then generate individual model pages
	for _, model := range models {
		if err := g.generateModelPage(dir, model, providerMap, authorMap); err != nil {
			return fmt.Errorf("generating model %s page: %w", model.ID, err)
		}
	}

	return nil
}

// generateModelIndex generates the main model listing page
func (g *Generator) generateModelIndex(dir string, models []*catalogs.Model) error {
	indexFile := filepath.Join(dir, "README.md")
	f, err := os.Create(indexFile)
	if err != nil {
		return fmt.Errorf("creating model index: %w", err)
	}
	defer f.Close()

	fmt.Fprintln(f, "# 🤖 All Models")
	fmt.Fprintln(f)
	fmt.Fprintf(f, "Complete listing of all %d models in the Starmap catalog.\n\n", len(models))

	// Quick stats
	fmt.Fprintln(f, "## Quick Stats")
	fmt.Fprintln(f)

	// Count by capability
	textCount, visionCount, audioCount, functionCount := 0, 0, 0, 0
	for _, model := range models {
		if model.Features != nil {
			if hasText(model.Features) {
				textCount++
			}
			if hasVision(model.Features) {
				visionCount++
			}
			if hasAudio(model.Features) {
				audioCount++
			}
			if hasToolSupport(model.Features) {
				functionCount++
			}
		}
	}

	fmt.Fprintln(f, "| Capability | Count | Percentage |")
	fmt.Fprintln(f, "|------------|-------|------------|")
	fmt.Fprintf(f, "| 📝 Text Generation | %d | %.1f%% |\n", textCount, float64(textCount)/float64(len(models))*100)
	fmt.Fprintf(f, "| 👁️ Vision | %d | %.1f%% |\n", visionCount, float64(visionCount)/float64(len(models))*100)
	fmt.Fprintf(f, "| 🎵 Audio | %d | %.1f%% |\n", audioCount, float64(audioCount)/float64(len(models))*100)
	fmt.Fprintf(f, "| 🔧 Function Calling | %d | %.1f%% |\n", functionCount, float64(functionCount)/float64(len(models))*100)
	fmt.Fprintln(f)

	// Model families
	families := make(map[string][]*catalogs.Model)
	for _, model := range models {
		family := detectModelFamily(model.Name)
		families[family] = append(families[family], model)
	}

	// Sort families by size
	type familyInfo struct {
		name   string
		models []*catalogs.Model
	}
	var familyList []familyInfo
	for name, models := range families {
		familyList = append(familyList, familyInfo{name, models})
	}
	sort.Slice(familyList, func(i, j int) bool {
		return len(familyList[i].models) > len(familyList[j].models)
	})

	// Display models by family
	fmt.Fprintln(f, "## Models by Family")
	fmt.Fprintln(f)

	for _, family := range familyList {
		fmt.Fprintf(f, "### %s (%d models)\n\n", family.name, len(family.models))

		// Sort models within family
		sort.Slice(family.models, func(i, j int) bool {
			return family.models[i].Name < family.models[j].Name
		})

		fmt.Fprintln(f, "| Model | Providers | Context | Input/Output |")
		fmt.Fprintln(f, "|-------|-----------|---------|--------------|")

		displayCount := 0
		for _, model := range family.models {
			if displayCount >= 10 && len(family.models) > 10 {
				fmt.Fprintf(f, "| _...and %d more_ | | | |\n", len(family.models)-10)
				break
			}

			// Model link
			modelLink := fmt.Sprintf("[%s](%s.md)", model.Name, formatModelID(string(model.ID)))

			// Provider count - TODO: get from catalog
			providerStr := "N/A"

			// Context
			contextStr := "—"
			if model.Limits != nil && model.Limits.ContextWindow > 0 {
				contextStr = formatContext(model.Limits.ContextWindow)
			}

			// Pricing
			pricingStr := "—"
			if model.Pricing != nil && model.Pricing.Tokens != nil {
				if model.Pricing.Tokens.Input != nil && model.Pricing.Tokens.Output != nil {
					pricingStr = fmt.Sprintf("$%.2f/$%.2f",
						model.Pricing.Tokens.Input.Per1M,
						model.Pricing.Tokens.Output.Per1M)
				}
			}

			fmt.Fprintf(f, "| %s | %s | %s | %s |\n",
				modelLink, providerStr, contextStr, pricingStr)

			displayCount++
		}

		fmt.Fprintln(f)
	}

	// Footer
	fmt.Fprintln(f, "---")
	fmt.Fprintln(f, "_[← Back to Catalog](../) | Generated by [Starmap](https://github.com/agentstation/starmap)_")

	return nil
}

// generateModelPage generates a detailed page for a single model
func (g *Generator) generateModelPage(dir string, model *catalogs.Model, 
	providerMap map[catalogs.ProviderID]*catalogs.Provider,
	authorMap map[catalogs.AuthorID]*catalogs.Author) error {

	modelFile := filepath.Join(dir, fmt.Sprintf("%s.md", formatModelID(string(model.ID))))
	f, err := os.Create(modelFile)
	if err != nil {
		return fmt.Errorf("creating model file: %w", err)
	}
	defer f.Close()

	// Header with model name
	fmt.Fprintf(f, "# %s\n\n", model.Name)

	// Description
	if model.Description != "" {
		fmt.Fprintf(f, "%s\n\n", model.Description)
	}

	// 📋 Overview Section
	fmt.Fprintln(f, "## 📋 Overview")
	fmt.Fprintln(f)
	fmt.Fprintf(f, "- **ID**: `%s`\n", model.ID)
	
	// Authors with links
	if len(model.Authors) > 0 {
		authorLinks := []string{}
		for _, author := range model.Authors {
			if a, ok := authorMap[author.ID]; ok {
				authorLinks = append(authorLinks, 
					fmt.Sprintf("[%s](../../authors/%s/)", a.Name, string(a.ID)))
			}
		}
		fmt.Fprintf(f, "- **Authors**: %s\n", strings.Join(authorLinks, ", "))
	}

	// Quick stats from metadata and limits
	if model.Metadata != nil {
		if !model.Metadata.ReleaseDate.IsZero() {
			fmt.Fprintf(f, "- **Release Date**: %s\n", model.Metadata.ReleaseDate.Format("2006-01-02"))
		}
		if model.Metadata.KnowledgeCutoff != nil {
			fmt.Fprintf(f, "- **Knowledge Cutoff**: %s\n", model.Metadata.KnowledgeCutoff.Format("2006-01-02"))
		}
		fmt.Fprintf(f, "- **Open Weights**: %t\n", model.Metadata.OpenWeights)
	}

	if model.Limits != nil {
		if model.Limits.ContextWindow > 0 {
			fmt.Fprintf(f, "- **Context Window**: %s tokens\n", formatNumber(int(model.Limits.ContextWindow)))
		}
		if model.Limits.OutputTokens > 0 {
			fmt.Fprintf(f, "- **Max Output**: %s tokens\n", formatNumber(int(model.Limits.OutputTokens)))
		}
	}

	// Architecture info if available
	if model.Metadata != nil && model.Metadata.Architecture != nil {
		if model.Metadata.Architecture.ParameterCount != "" {
			fmt.Fprintf(f, "- **Parameters**: %s\n", model.Metadata.Architecture.ParameterCount)
		}
	}

	fmt.Fprintln(f)

	// 🎯 Capabilities Section with horizontal tables
	fmt.Fprintln(f, "## 🎯 Capabilities")
	fmt.Fprintln(f)
	
	// Input/Output Modalities Table
	fmt.Fprintln(f, "### Input/Output Modalities")
	fmt.Fprintln(f)
	writeModalityTable(f, model)
	
	// Core Features Table
	fmt.Fprintln(f, "### Core Features")
	fmt.Fprintln(f)
	writeCoreFeatureTable(f, model)
	
	// Response Delivery Table
	fmt.Fprintln(f, "### Response Delivery")
	fmt.Fprintln(f)
	writeResponseDeliveryTable(f, model)
	
	// Advanced Reasoning Table (only if applicable)
	writeAdvancedReasoningTable(f, model)

	// 🎛️ Generation Controls section with horizontal tables
	fmt.Fprintln(f, "## 🎛️ Generation Controls")
	fmt.Fprintln(f)
	
	// Architecture table (if available)
	writeArchitectureTable(f, model)
	
	// Model Tags table (if available)
	writeTagsTable(f, model)
	
	// Generation Controls tables
	writeControlsTables(f, model)

	// 💰 Pricing section with horizontal tables
	fmt.Fprintln(f, "## 💰 Pricing")
	fmt.Fprintln(f)
	
	// Token Pricing Table
	writeTokenPricingTable(f, model)
	
	// Operation Pricing Table (if applicable)
	writeOperationPricingTable(f, model)
	
	// Cost Calculator and Example Costs
	writeCostCalculator(f, model)
	writeExampleCosts(f, model)

	// Advanced Features section
	hasAdvancedFeatures := false
	advancedSection := strings.Builder{}
	advancedSection.WriteString("## 🚀 Advanced Features\n\n")

	// Tool configuration
	if model.Tools != nil && len(model.Tools.ToolChoices) > 0 {
		advancedSection.WriteString("### Tool Configuration\n\n")
		var choices []string
		for _, choice := range model.Tools.ToolChoices {
			choices = append(choices, string(choice))
		}
		advancedSection.WriteString(fmt.Sprintf("**Supported Tool Choices**: %s\n\n", strings.Join(choices, ", ")))
		hasAdvancedFeatures = true
	}

	// Attachments support
	if model.Attachments != nil {
		advancedSection.WriteString("### File Attachments\n\n")
		if len(model.Attachments.MimeTypes) > 0 {
			advancedSection.WriteString(fmt.Sprintf("**Supported Types**: %s\n", strings.Join(model.Attachments.MimeTypes, ", ")))
		}
		if model.Attachments.MaxFileSize != nil {
			advancedSection.WriteString(fmt.Sprintf("**Max File Size**: %s bytes\n", formatNumber(int(*model.Attachments.MaxFileSize))))
		}
		if model.Attachments.MaxFiles != nil {
			advancedSection.WriteString(fmt.Sprintf("**Max Files**: %d per request\n", *model.Attachments.MaxFiles))
		}
		advancedSection.WriteString("\n")
		hasAdvancedFeatures = true
	}

	// Delivery options
	if model.Delivery != nil && (len(model.Delivery.Formats) > 0 || len(model.Delivery.Streaming) > 0 || len(model.Delivery.Protocols) > 0) {
		advancedSection.WriteString("### Response Delivery\n\n")
		if len(model.Delivery.Formats) > 0 {
			var formats []string
			for _, format := range model.Delivery.Formats {
				formats = append(formats, string(format))
			}
			advancedSection.WriteString(fmt.Sprintf("**Response Formats**: %s\n", strings.Join(formats, ", ")))
		}
		if len(model.Delivery.Streaming) > 0 {
			var streaming []string
			for _, stream := range model.Delivery.Streaming {
				streaming = append(streaming, string(stream))
			}
			advancedSection.WriteString(fmt.Sprintf("**Streaming Modes**: %s\n", strings.Join(streaming, ", ")))
		}
		if len(model.Delivery.Protocols) > 0 {
			var protocols []string
			for _, protocol := range model.Delivery.Protocols {
				protocols = append(protocols, string(protocol))
			}
			advancedSection.WriteString(fmt.Sprintf("**Protocols**: %s\n", strings.Join(protocols, ", ")))
		}
		advancedSection.WriteString("\n")
		hasAdvancedFeatures = true
	}

	if hasAdvancedFeatures {
		fmt.Fprint(f, advancedSection.String())
	}

	// 📋 Metadata section
	fmt.Fprintln(f, "## 📋 Metadata")
	fmt.Fprintln(f)
	if model.Metadata != nil && len(model.Metadata.Tags) > 0 {
		var tags []string
		for _, tag := range model.Metadata.Tags {
			tags = append(tags, fmt.Sprintf("`%s`", string(tag)))
		}
		fmt.Fprintf(f, "**Use Case Tags**: %s\n", strings.Join(tags, " "))
	}
	fmt.Fprintf(f, "**Created**: %s\n", model.CreatedAt.Format("2006-01-02 15:04:05 UTC"))
	fmt.Fprintf(f, "**Last Updated**: %s\n", model.UpdatedAt.Format("2006-01-02 15:04:05 UTC"))
	fmt.Fprintln(f)

	// Footer with navigation
	fmt.Fprintln(f, "---")
	fmt.Fprintln(f)
	
	// Navigation links
	fmt.Fprintln(f, "### Navigation")
	fmt.Fprintln(f)
	if len(model.Authors) > 0 {
		for _, author := range model.Authors {
			if a, ok := authorMap[author.ID]; ok {
				fmt.Fprintf(f, "- More models by [%s](../../authors/%s/)\n", a.Name, string(a.ID))
			}
		}
	}
	// TODO: Get hosting providers from catalog
	// This would require checking which providers host this model
	fmt.Fprintln(f, "- [All Models](../)")
	fmt.Fprintln(f, "- [Back to Catalog](../../)")
	fmt.Fprintln(f)

	fmt.Fprintf(f, "_Last Updated: %s | Generated by [Starmap](https://github.com/agentstation/starmap)_\n",
		time.Now().Format("January 2, 2006"))

	return nil
}

// generateModelBadges generates status and feature badges for a model
func modelBadges(model *catalogs.Model) string {
	var badges []string

	// Status badges
	// TODO: Check if model has deprecation info in metadata
	badges = append(badges, "![Active](https://img.shields.io/badge/status-active-green)")

	// Feature badges
	if model.Features != nil {
		if hasVision(model.Features) {
			badges = append(badges, "![Vision](https://img.shields.io/badge/vision-✓-blue)")
		}
		if hasAudio(model.Features) {
			badges = append(badges, "![Audio](https://img.shields.io/badge/audio-✓-blue)")
		}
		if hasVideo(model.Features) {
			badges = append(badges, "![Video](https://img.shields.io/badge/video-✓-blue)")
		}
		if hasToolSupport(model.Features) {
			badges = append(badges, "![Functions](https://img.shields.io/badge/functions-✓-blue)")
		}
		if model.Features.Streaming {
			badges = append(badges, "![Streaming](https://img.shields.io/badge/streaming-✓-blue)")
		}
	}

	// Context size badge
	if model.Limits != nil && model.Limits.ContextWindow > 0 {
		contextLabel := formatContext(model.Limits.ContextWindow)
		badges = append(badges, fmt.Sprintf("![Context](https://img.shields.io/badge/context-%s-purple)",
			strings.ReplaceAll(contextLabel, " ", "%20")))
	}

	return strings.Join(badges, " ")
}


// generateModalitiesTable generates a table for multimodal capabilities

// generateLimitsTable generates a table for model limits
func writeLimitsTable(f *os.File, limits *catalogs.ModelLimits) {
	fmt.Fprintln(f, "| Limit | Value | Notes |")
	fmt.Fprintln(f, "|-------|-------|-------|")

	if limits.ContextWindow > 0 {
		fmt.Fprintf(f, "| **Context Window** | %s | Maximum tokens in conversation |\n",
			formatNumber(int(limits.ContextWindow)))
	}

	if limits.OutputTokens > 0 {
		fmt.Fprintf(f, "| **Max Output** | %s tokens | Maximum response length |\n",
			formatNumber(int(limits.OutputTokens)))
	}
}

// generatePricingSection generates comprehensive pricing information
func writePricingSection(f *os.File, pricing *catalogs.ModelPricing) {
	if pricing.Tokens != nil {
		fmt.Fprintln(f, "### Token Pricing")
		fmt.Fprintln(f)
		fmt.Fprintln(f, "| Type | Per 1M Tokens | Per 1K Tokens | Notes |")
		fmt.Fprintln(f, "|------|---------------|---------------|-------|")

		if pricing.Tokens.Input != nil {
			per1k := pricing.Tokens.Input.Per1M / 1000
			notes := ""
			if pricing.Tokens.Input.Per1M == 0 {
				notes = "Free tier available"
			}
			fmt.Fprintf(f, "| **Input** | $%.4f | $%.6f | %s |\n",
				pricing.Tokens.Input.Per1M, per1k, notes)
		}

		if pricing.Tokens.Output != nil {
			per1k := pricing.Tokens.Output.Per1M / 1000
			notes := ""
			if pricing.Tokens.Output.Per1M == 0 {
				notes = "Free tier available"
			}
			fmt.Fprintf(f, "| **Output** | $%.4f | $%.6f | %s |\n",
				pricing.Tokens.Output.Per1M, per1k, notes)
		}

		// Calculate example costs
		fmt.Fprintln(f)
		fmt.Fprintln(f, "### Example Costs")
		fmt.Fprintln(f)
		writeExampleCosts(f, pricing.Tokens)
	}

	// Operation pricing if applicable
	if pricing.Operations != nil && pricing.Operations.ImageGen != nil {
		fmt.Fprintln(f)
		fmt.Fprintln(f, "### Image Generation Pricing")
		fmt.Fprintln(f)
		fmt.Fprintf(f, "| Per Image | $%.4f |\n", *pricing.Operations.ImageGen)
	}
}

// generateExampleCosts generates example cost calculations
func writeExampleCosts(f *os.File, tokens *catalogs.TokenPricing) {
	examples := []struct {
		name   string
		input  int
		output int
	}{
		{"Short conversation", 500, 500},
		{"Long document", 10000, 2000},
		{"Extended chat", 50000, 10000},
	}

	fmt.Fprintln(f, "| Use Case | Input Tokens | Output Tokens | Total Cost |")
	fmt.Fprintln(f, "|----------|--------------|---------------|------------|")

	for _, ex := range examples {
		inputCost := 0.0
		outputCost := 0.0
		
		if tokens.Input != nil {
			inputCost = float64(ex.input) / 1000000 * tokens.Input.Per1M
		}
		if tokens.Output != nil {
			outputCost = float64(ex.output) / 1000000 * tokens.Output.Per1M
		}

		totalCost := inputCost + outputCost
		fmt.Fprintf(f, "| %s | %s | %s | $%.6f |\n",
			ex.name, formatNumber(ex.input), formatNumber(ex.output), totalCost)
	}
}

// generateUsageExamples generates usage examples for different providers
func writeUsageExamples(f *os.File, model *catalogs.Model, 
	providerMap map[catalogs.ProviderID]*catalogs.Provider) {

	fmt.Fprintln(f, "### With Starmap CLI")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "```bash")
	fmt.Fprintln(f, "# Get detailed model information")
	fmt.Fprintf(f, "starmap show model %s\n", model.ID)
	fmt.Fprintln(f)
	fmt.Fprintln(f, "# List all providers offering this model")
	fmt.Fprintf(f, "starmap list providers --model %s\n", model.ID)
	fmt.Fprintln(f, "```")

	// Provider-specific examples - TODO: get from catalog
	// This would need to check which providers host this model
	if false { // Disabled for now
		fmt.Fprintln(f)
		fmt.Fprintln(f, "### Provider APIs")
		fmt.Fprintln(f)

		for _, providerID := range []catalogs.ProviderID{} { // Empty for now
			if provider, ok := providerMap[providerID]; ok {
				fmt.Fprintf(f, "#### %s\n\n", provider.Name)
				
				switch provider.ID {
				case "openai":
					fmt.Fprintln(f, "```python")
					fmt.Fprintln(f, "from openai import OpenAI")
					fmt.Fprintln(f, "client = OpenAI()")
					fmt.Fprintln(f)
					fmt.Fprintln(f, "response = client.chat.completions.create(")
					fmt.Fprintf(f, "    model=\"%s\",\n", model.ID)
					fmt.Fprintln(f, "    messages=[{\"role\": \"user\", \"content\": \"Hello!\"}]")
					fmt.Fprintln(f, ")")
					fmt.Fprintln(f, "```")

				case "anthropic":
					fmt.Fprintln(f, "```python")
					fmt.Fprintln(f, "from anthropic import Anthropic")
					fmt.Fprintln(f, "client = Anthropic()")
					fmt.Fprintln(f)
					fmt.Fprintln(f, "response = client.messages.create(")
					fmt.Fprintf(f, "    model=\"%s\",\n", model.ID)
					fmt.Fprintln(f, "    messages=[{\"role\": \"user\", \"content\": \"Hello!\"}],")
					fmt.Fprintln(f, "    max_tokens=1000")
					fmt.Fprintln(f, ")")
					fmt.Fprintln(f, "```")

				default:
					fmt.Fprintln(f, "```bash")
					fmt.Fprintln(f, "# Check provider documentation for API usage")
					fmt.Fprintf(f, "# Model ID: %s\n", model.ID)
					fmt.Fprintln(f, "```")
				}
				fmt.Fprintln(f)
			}
		}
	}
}

// generateComparisonTable generates a comparison with similar models
func writeComparisonTable(f *os.File, model *catalogs.Model, similar []*catalogs.Model) {
	fmt.Fprintln(f, "| Model | Context | Input $/1M | Output $/1M | Features |")
	fmt.Fprintln(f, "|-------|---------|------------|-------------|----------|")

	// Current model first
	writeComparisonRow(f, model, true)

	// Similar models
	for _, m := range similar[:min(5, len(similar))] {
		writeComparisonRow(f, m, false)
	}
}

// generateComparisonRow generates a single row in the comparison table
func writeComparisonRow(f *os.File, model *catalogs.Model, highlight bool) {
	name := model.Name
	if highlight {
		name = "**" + name + "** (this)"
	} else {
		name = fmt.Sprintf("[%s](%s.md)", name, formatModelID(string(model.ID)))
	}

	context := "—"
	if model.Limits != nil && model.Limits.ContextWindow > 0 {
		context = formatContext(model.Limits.ContextWindow)
	}

	inputPrice := "—"
	outputPrice := "—"
	if model.Pricing != nil && model.Pricing.Tokens != nil {
		if model.Pricing.Tokens.Input != nil {
			inputPrice = fmt.Sprintf("$%.2f", model.Pricing.Tokens.Input.Per1M)
		}
		if model.Pricing.Tokens.Output != nil {
			outputPrice = fmt.Sprintf("$%.2f", model.Pricing.Tokens.Output.Per1M)
		}
	}

	features := compactFeatures(*model)

	fmt.Fprintf(f, "| %s | %s | %s | %s | %s |\n",
		name, context, inputPrice, outputPrice, features)
}

// findSimilarModels finds models similar to the given one
func findSimilarModels(model *catalogs.Model, providerMap map[catalogs.ProviderID]*catalogs.Provider) []*catalogs.Model {
	var similar []*catalogs.Model

	// Find models from same family
	family := detectModelFamily(model.Name)

	// Get all models from providers
	for _, provider := range providerMap {
		for i := range provider.Models {
			m := provider.Models[i] // Copy the model
			if m.ID != model.ID && detectModelFamily(m.Name) == family {
				similar = append(similar, &m)
			}
		}
	}

	// Sort by name
	sort.Slice(similar, func(i, j int) bool {
		return similar[i].Name < similar[j].Name
	})

	return similar
}

// hasMultipleModalities checks if model supports multiple modalities
func hasMultipleModalities(model *catalogs.Model) bool {
	return isMultimodal(model.Features)
}